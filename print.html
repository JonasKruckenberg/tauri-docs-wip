<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Tauri Documentation WIP</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><div>Draft</div></li><li class="chapter-item expanded affix "><a href="prerequisites.html">Prerequisites</a></li><li class="chapter-item expanded affix "><div>Migrated</div></li><li class="chapter-item expanded "><a href="quick-start/index.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick-start/html-css-js.html"><strong aria-hidden="true">1.1.</strong> HTML/CSS/JS</a></li><li class="chapter-item expanded "><a href="quick-start/vite.html"><strong aria-hidden="true">1.2.</strong> Vite</a></li><li class="chapter-item expanded "><a href="quick-start/webpack.html"><strong aria-hidden="true">1.3.</strong> Webpack</a></li></ol></li><li class="chapter-item expanded "><a href="background/index.html"><strong aria-hidden="true">2.</strong> Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="background/process-model.html"><strong aria-hidden="true">2.1.</strong> Process Model</a></li><li class="chapter-item expanded "><a href="background/inter-process-communication.html"><strong aria-hidden="true">2.2.</strong> Inter-Process Communication</a></li><li class="chapter-item expanded "><a href="background/security/index.html"><strong aria-hidden="true">2.3.</strong> Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="background/security/context-isolation.html"><strong aria-hidden="true">2.3.1.</strong> Context Isolation</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Development</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Configuration</div></li><li class="chapter-item expanded "><a href="development/inter-process-communication.html"><strong aria-hidden="true">3.2.</strong> Inter-Process Communication</a></li><li class="chapter-item expanded "><a href="development/windows-and-webviews.html"><strong aria-hidden="true">3.3.</strong> Windows &amp; Webviews</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> State Management</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Tauri Plugins</div></li><li class="chapter-item expanded "><a href="development/debugging.html"><strong aria-hidden="true">3.6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">3.7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="development/vms.html"><strong aria-hidden="true">3.8.</strong> Virtual Machines</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Building</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="building/building-your-application.html"><strong aria-hidden="true">4.1.</strong> Building your Application</a></li><li class="chapter-item expanded "><a href="building/linux.html"><strong aria-hidden="true">4.2.</strong> Linux</a></li><li class="chapter-item expanded "><a href="building/windows-installer.html"><strong aria-hidden="true">4.3.</strong> Windows Installer</a></li><li class="chapter-item expanded "><a href="building/macos-bundle.html"><strong aria-hidden="true">4.4.</strong> macOS Bundle</a></li><li class="chapter-item expanded "><a href="building/updater-artifacts.html"><strong aria-hidden="true">4.5.</strong> Updater Artifacts</a></li><li class="chapter-item expanded "><a href="building/reducing-the-app-size.html"><strong aria-hidden="true">4.6.</strong> Reducing the App Size</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Distributing</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="distributing/windows.html"><strong aria-hidden="true">5.1.</strong> Windows</a></li><li class="chapter-item expanded "><a href="distributing/macos.html"><strong aria-hidden="true">5.2.</strong> macOS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Linux</div></li><li class="chapter-item expanded "><a href="distributing/updater.html"><strong aria-hidden="true">5.4.</strong> Updater</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Examples</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/window-customization.html"><strong aria-hidden="true">6.1.</strong> Window Customization</a></li><li class="chapter-item expanded "><a href="examples/native-application-menu.html"><strong aria-hidden="true">6.2.</strong> Native Application Menu</a></li><li class="chapter-item expanded "><a href="examples/system-tray.html"><strong aria-hidden="true">6.3.</strong> System Tray</a></li><li class="chapter-item expanded "><a href="examples/sidecar.html"><strong aria-hidden="true">6.4.</strong> Sidecar</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Notifications</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> Keyboard Shortcuts</div></li><li class="chapter-item expanded "><a href="examples/splashscreen.html"><strong aria-hidden="true">6.7.</strong> Splashscreen</a></li><li class="chapter-item expanded "><a href="examples/icons.html"><strong aria-hidden="true">6.8.</strong> Icons</a></li><li class="chapter-item expanded "><a href="examples/command-line-interface.html"><strong aria-hidden="true">6.9.</strong> Command Line Interface</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Appendix</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> A - Useful Development Tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> B - How Tauri is Made</div></li><li class="chapter-item expanded "><a href="appendix/version-tables.html"><strong aria-hidden="true">7.3.</strong> C - Version Tables</a></li><li class="chapter-item expanded "><a href="appendix/json-schemas.html"><strong aria-hidden="true">7.4.</strong> D - JSON Schemas</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Tauri Documentation WIP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/JonasKruckenberg/tauri-docs-wip" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-tauri-documentation-wip"><a class="header" href="#the-tauri-documentation-wip">The Tauri Documentation WIP</a></h1>
<picture>
    <source srcset="img/banner.avif" type="image/avif">
    <source srcset="img/banner.webp" type="image/webp">
    <img src="img/banner.png" alt="Tauri Banner">
</picture>
<blockquote>
<p>This is my <strong>work-in-progress</strong> version of the new tauri
documentation. Beware of typos, inaccuracies, mistakes and missing
pages!</p>
</blockquote>
<p>Tauri is a toolkit that helps developers make applications for the
major desktop platforms - using virtually any frontend framework in
existence. The core is built with Rust, and the CLI leverages Node.js
making Tauri a genuinely polyglot approach to creating and maintaining
great apps.</p>
<!-- TODO: Why Tauri? -->
<p><span id="ferris"></span></p>
<p>Once in a while, we will show you code examples that do not work or do
not compile. In most situations, we lead you to correct solution and
the Rust mascot Ferris will always draw your attention to code that
isn't meant to work:</p>
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/compile_fail.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="img/ferris/should_panic.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>This code panics!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>The first step is to install <a href="https://www.rust-lang.org">Rust</a> and System Dependencies. Keep in
mind that this setup is only needed for <em>developing Tauri apps</em>. Your
end-users are not required to do any of this. You'll need an internet
connection for the download.</p>
<h2 id="setting-up-windows"><a class="header" href="#setting-up-windows">Setting Up Windows</a></h2>
<blockquote>
<p>For those using the Windows Subsystem for Linux (WSL), please refer
to our <a href="prerequisites.html#setting-up-linux">Linux specific instructions</a> instead.</p>
</blockquote>
<p>On Windows, go to
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> to install
<code>rustup</code> the Rust installer. You also need to install Microsoft Visual
Studio C++ build tools. The easiest way is to install <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Build Tools for
Visual Studio 2019</a>. When asked which workloads to install, ensure
&quot;C++ build tools&quot; and the Windows 10 SDK are selected.</p>
<h3 id="install-webview2"><a class="header" href="#install-webview2">Install WebView2</a></h3>
<blockquote>
<p>WebView2 is pre-installed in Windows 11.</p>
</blockquote>
<p>Tauri heavily depends on WebView2 to render web content on Windows,
therefore you must have WebView2 installed. The easiest way is to
download and run the Evergreen Bootstrapper from the <a href="https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section">official
website</a>. <br> The bootstrapper script will try to
determine the correct architecture and version for your system. Still,
if you run into issues - especially with Windows on ARM - you can
select te correct Standalone Installer or even a fixed version.</p>
<h2 id="setting-up-macos"><a class="header" href="#setting-up-macos">Setting Up macOS</a></h2>
<p>To install Rust on macOS, open a terminal and enter the following
command:</p>
<pre><code class="language-console">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<blockquote>
<p>We have audited this bash script, and it does what it says it is
supposed to do. Nevertheless, before blindly curl-bashing a script,
it is always wise to look at it first. Here is the file as a plain
<a href="https://sh.rustup.rs">download link</a>.</p>
</blockquote>
<p>The command downloads a script and starts the installation of the
<code>rustup</code> tool, which installs the latest stable version of Rust. You
might be prompted for your password. If the installation was
successful, the following line will appear:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>You also need to install CLang and macOS development dependencies. To
do this, run the following command in your terminal:</p>
<pre><code class="language-console">xcode-select --install
</code></pre>
<h2 id="setting-up-linux"><a class="header" href="#setting-up-linux">Setting Up Linux</a></h2>
<p>To install Rust on Linux, open a terminal and enter the following
command:</p>
<pre><code class="language-console">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<blockquote>
<p>We have audited this bash script, and it does what it says it is
supposed to do. Nevertheless, before blindly curl-bashing a script,
it is always wise to look at it first. Here is the file as a plain
<a href="https://sh.rustup.rs">download link</a>.</p>
</blockquote>
<p>The command downloads a script and starts the installation of the
<code>rustup</code> tool, which installs the latest stable version of Rust. You
might be prompted for your password. If the installation was
successful, the following line will appear:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>You also need to install a couple of system dependencies, such as a C
compiler and <code>webkit2gtk</code>. Below are commands for a few popular
distributions.</p>
<h4 id="debian"><a class="header" href="#debian">Debian</a></h4>
<pre><code class="language-console">sudo apt update
sudo apt install libwebkit2gtk-4.0-dev \
    build-essential \
    curl \
    wget \
    libssl-dev \
    libgtk-3-dev \
    libappindicator3-dev \
    librsvg2-dev
</code></pre>
<h4 id="arch"><a class="header" href="#arch">Arch</a></h4>
<pre><code class="language-console">sudo pacman -Syu
sudo pacman -S --needed \
    webkit2gtk \
    base-devel \
    curl \
    wget \
    openssl \
    appmenu-gtk-module \
    gtk3 \
    libappindicator-gtk3 \
    librsvg \
    libvips
</code></pre>
<h4 id="fedora"><a class="header" href="#fedora">Fedora</a></h4>
<pre><code class="language-console">sudo dnf check-update
sudo dnf install webkit2gtk3-devel.x86_64 \
    openssl-devel \
    curl \
    wget \
    libappindicator-gtk3 \
    librsvg2-devel
sudo dnf group install &quot;C Development Tools and Libraries&quot;
</code></pre>
<h3 id="windows-subsystem-for-linux-wsl"><a class="header" href="#windows-subsystem-for-linux-wsl">Windows Subsystem for Linux (WSL)</a></h3>
<p>To run a graphical application with WSL, you need to download one of
these X servers: Xming, Cygwin X, and vcXsrv. Since vcXsrv has been
used internally, it's the one we recommend installing.</p>
<h3 id="wsl-version-1"><a class="header" href="#wsl-version-1">WSL Version 1​</a></h3>
<p>Open the X server and then run</p>
<pre><code class="language-console">export DISPLAY=:0
</code></pre>
<p>in the terminal. You should now be able to run any graphical
application via the terminal.</p>
<h3 id="wsl-version-2"><a class="header" href="#wsl-version-2">WSL Version 2</a></h3>
<p>You'll need to run a command that is slightly more complex than WSL 1:</p>
<pre><code class="language-console">export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0
</code></pre>
<p>and you need to add -ac to the X server as an argument. If for some
reason this command doesn't work you can use an alternative command
such as:</p>
<pre><code class="language-console">export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | sed 's/.* //g'):0
</code></pre>
<p>or you can manually find the Address using:</p>
<pre><code class="language-console">cat /etc/resolve.conf | grep nameserver
</code></pre>
<blockquote>
<p>Don't forget that you'll have to use the &quot;export&quot; command anytime
you want to use a graphical application for each newly opened
terminal.</p>
<p>You can download some examples to try with
<code>sudo apt-get install x11-apps</code>. xeyes is always a good one. It can
be handy when troubleshooting WSL issues.</p>
</blockquote>
<h2 id="updating-and-uninstalling"><a class="header" href="#updating-and-uninstalling">Updating and Uninstalling</a></h2>
<p>Tauri and its components can be manually updated by editing the
<code>Cargo.toml</code> file or running the <code>cargo upgrade</code> command that is part
of the <a href="https://github.com/killercup/cargo-edit"><code>cargo-edit</code></a> tool. Open a terminal and enter the following
command:</p>
<pre><code class="language-console">cargo upgrade
</code></pre>
<p>Updating Rust itself is easy via <code>rustup</code>. Open a terminal and run the
following command:</p>
<pre><code class="language-console">rustup update
</code></pre>
<p><code>rustup</code> can also be used to uninstall Rust from your machine fully:</p>
<pre><code class="language-console">rustup self uninstall
</code></pre>
<!-- TODO: Unistall Webview2 -->
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>To check whether you have Rust installed correctly, open a shell and
enter this line:</p>
<pre><code class="language-console">rustc --version
</code></pre>
<p>You should see the version number, commit hash, and commit date for
the latest stable version that has been released in the following
format:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>If you don't see this information, your Rust installation might be
broken. Please consult <a href="https://doc.rust-lang.org/book/ch01-01-installation.html#troubleshooting">Rust's Troubleshooting Section</a> on how to fix
this. If your problems persist, you can get help from the official
<a href="https://discord.com/invite/tauri-apps">Tauri Discord</a> and <a href="https://github.com/tauri-apps/tauri/discussions">GitHub Discussions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<blockquote>
<p><strong>Prerequisites</strong></p>
<p>We expect you to have a working development environment from here on
out. Please see the <a href="quick-start/../prerequisites.html">Prerequisites</a> page if you haven't done this
yet.</p>
</blockquote>
<div class="card-wrapper">
<!-- two newlines here to create separate <p>'s for each image -->
<p><a href="quick-start/./vite.html"><img src="quick-start/../img/vite.svg" alt="Vite Logo" /> <strong>Vite</strong></a></p>
<p><a href="quick-start/./webpack.html"><img src="quick-start/../img/webpack.svg" alt="Webpack Logo" /> <strong>Webpack</strong></a></p>
<p><a href="quick-start/./html-css-js.html"><img src="quick-start/../img/HTML5.svg" alt="HTML5 Logo" /> <strong>HTML/CSS/JS</strong></a></p>
</div>
<h2 id="dont-know-where-to-start"><a class="header" href="#dont-know-where-to-start">Don't know where to start?</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="htmlcssjs"><a class="header" href="#htmlcssjs">HTML/CSS/JS</a></h1>
<blockquote>
<p><strong>Prerequisites</strong></p>
<p>We expect you to have a working development environment from here on
out. Please see the <a href="quick-start/../prerequisites.html">Prerequisites</a> page if you haven't done this
yet.</p>
</blockquote>
<h2 id="the-tauri-cli"><a class="header" href="#the-tauri-cli">The Tauri CLI</a></h2>
<p>The Tauri CLI is the magic glue, that makes it all work: It
orchestrates your frontend development server and cargo during
development and bundles the rust binary and associated resources
(sidecars or icons) into the final distributable app. You can install
it from various sources, depending on your preference:</p>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p>The CLI is written in Rust, so its primary distribution mechanism is
cargo:</p>
<pre><code class="language-console">cargo install tauri-cli
</code></pre>
<p>Please note that cargo has no support for prebuilt binaries, so the
above command will always build the CLI from source.</p>
<h3 id="javascript-package-managers"><a class="header" href="#javascript-package-managers">JavaScript Package Managers</a></h3>
<p>If you don't want to build the CLI from source or want to lock and
version it for reproducible builds, we also distribute the CLI as an
NPM package: <a href="https://www.npmjs.com/package/@tauri-apps/cli"><code>@tauri-apps/cli</code></a>.</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install --save-dev @tauri-apps/cli
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D @tauri-apps/cli
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D @tauri-apps/cli
</code></pre>
<h2 id="scaffold-the-project"><a class="header" href="#scaffold-the-project">Scaffold the Project</a></h2>
<blockquote>
<p>The easiest way to scaffold a Tauri app is
<a href="https://github.com/tauri-apps/create-tauri-app"><code>create-tauri-app</code></a></p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx create-tauri-app
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn create tauri-app
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm create tauri-app
</code></pre>
</blockquote>
<blockquote>
<p>Just follow the prompts and select the <code>Vanilla.js</code> recipe!</p>
</blockquote>
<h2 id="create-the-frontend"><a class="header" href="#create-the-frontend">Create the Frontend</a></h2>
<h2 id="open-a-window"><a class="header" href="#open-a-window">Open a Window</a></h2>
<h2 id="invoke-commands"><a class="header" href="#invoke-commands">Invoke Commands</a></h2>
<h2 id="recap"><a class="header" href="#recap">Recap</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vite"><a class="header" href="#vite">Vite</a></h1>
<blockquote>
<p><strong>Prerequisites</strong></p>
<p>We expect you to have a working development environment from here on
out. Please see the <a href="quick-start/../prerequisites.html">Prerequisites</a> page if you haven't done this
yet.</p>
</blockquote>
<h2 id="the-tauri-cli-1"><a class="header" href="#the-tauri-cli-1">The Tauri CLI</a></h2>
<p>The Tauri CLI is the magic glue, that makes it all work: It
orchestrates your frontend development server and cargo during
development and bundles the rust binary and associated resources
(sidecars or icons) into the final distributable app. You can install
it from various sources, depending on your preference:</p>
<h3 id="cargo-1"><a class="header" href="#cargo-1">Cargo</a></h3>
<p>The CLI is written in Rust, so its primary distribution mechanism is
cargo:</p>
<pre><code class="language-console">cargo install tauri-cli
</code></pre>
<p>Please note that cargo has no support for prebuilt binaries, so the
above command will always build the CLI from source.</p>
<h3 id="javascript-package-managers-1"><a class="header" href="#javascript-package-managers-1">JavaScript Package Managers</a></h3>
<p>If you don't want to build the CLI from source or want to lock and
version it for reproducible builds, we also distribute the CLI as an
NPM package: <a href="https://www.npmjs.com/package/@tauri-apps/cli"><code>@tauri-apps/cli</code></a>.</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install --save-dev @tauri-apps/cli
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D @tauri-apps/cli
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D @tauri-apps/cli
</code></pre>
<h2 id="scaffold-the-project-1"><a class="header" href="#scaffold-the-project-1">Scaffold the Project</a></h2>
<blockquote>
<p>The easiest way to scaffold a Tauri app is
<a href="https://github.com/tauri-apps/create-tauri-app"><code>create-tauri-app</code></a></p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx create-tauri-app
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn create tauri-app
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm create tauri-app
</code></pre>
</blockquote>
<blockquote>
<p>Just follow the prompts and select the <code>create-vite</code> recipe!</p>
</blockquote>
<h2 id="create-the-frontend-1"><a class="header" href="#create-the-frontend-1">Create the Frontend</a></h2>
<h2 id="open-a-window-1"><a class="header" href="#open-a-window-1">Open a Window</a></h2>
<h2 id="invoke-commands-1"><a class="header" href="#invoke-commands-1">Invoke Commands</a></h2>
<h2 id="recap-1"><a class="header" href="#recap-1">Recap</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webpack"><a class="header" href="#webpack">Webpack</a></h1>
<blockquote>
<p><strong>Prerequisites</strong></p>
<p>We expect you to have a working development environment from here on
out. Please see the <a href="quick-start/../prerequisites.html">Prerequisites</a> page if you haven't done this
yet.</p>
</blockquote>
<h2 id="the-tauri-cli-2"><a class="header" href="#the-tauri-cli-2">The Tauri CLI</a></h2>
<p>The Tauri CLI is the magic glue, that makes it all work: It
orchestrates your frontend development server and cargo during
development and bundles the rust binary and associated resources
(sidecars or icons) into the final distributable app. You can install
it from various sources, depending on your preference:</p>
<h3 id="cargo-2"><a class="header" href="#cargo-2">Cargo</a></h3>
<p>The CLI is written in Rust, so its primary distribution mechanism is
cargo:</p>
<pre><code class="language-console">cargo install tauri-cli
</code></pre>
<p>Please note that cargo has no support for prebuilt binaries, so the
above command will always build the CLI from source.</p>
<h3 id="javascript-package-managers-2"><a class="header" href="#javascript-package-managers-2">JavaScript Package Managers</a></h3>
<p>If you don't want to build the CLI from source or want to lock and
version it for reproducible builds, we also distribute the CLI as an
NPM package: <a href="https://www.npmjs.com/package/@tauri-apps/cli"><code>@tauri-apps/cli</code></a>.</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install --save-dev @tauri-apps/cli
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D @tauri-apps/cli
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D @tauri-apps/cli
</code></pre>
<h2 id="scaffold-the-project-2"><a class="header" href="#scaffold-the-project-2">Scaffold the Project</a></h2>
<blockquote>
<p>The easiest way to scaffold a Tauri app is
<a href="https://github.com/tauri-apps/create-tauri-app"><code>create-tauri-app</code></a></p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx create-tauri-app
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn create tauri-app
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm create tauri-app
</code></pre>
</blockquote>
<blockquote>
<p>While we offer no &quot;plain webpack&quot; recipe, the <code>Vue CLI</code> recipe uses
webpack under the hood.</p>
</blockquote>
<h2 id="create-the-frontend-2"><a class="header" href="#create-the-frontend-2">Create the Frontend</a></h2>
<h2 id="open-a-window-2"><a class="header" href="#open-a-window-2">Open a Window</a></h2>
<h2 id="invoke-commands-2"><a class="header" href="#invoke-commands-2">Invoke Commands</a></h2>
<h2 id="recap-2"><a class="header" href="#recap-2">Recap</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<p>Now that you have completed the Quick Start and have a basic Tauri
application at hand, it is tempting to jump right in. I invite you,
however, to resist this temptation for a couple more pages and learn
more about the concepts and ideas behind Tauri. You will find
developing an app is much like creating a traditional client-server
application on the web, with a couple of subtle but important
differences.</p>
<p>This chapter will cover Tauris multi-process architecture, windows,
and webviews and our design decisions to make your application more
secure and resource efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="process-model"><a class="header" href="#process-model">Process Model</a></h1>
<p>Tauri employs a multi-process architecture similar to Electron or many
modern web browsers. This guide explores the reasons behind the design
choice and why it is key to writing secure applications.</p>
<h2 id="why-multiple-processes"><a class="header" href="#why-multiple-processes">Why Multiple Processes?</a></h2>
<p>In the early days of GUI applications, it was common to use a single
process to perform computation, draw the interface and react to user
input. As you can probably guess, this meant that a long-running,
expensive computation would leave the user interface unresponsive or,
worse, a failure in one app component would bring the whole app
crashing down.</p>
<p>It became clear that a more resilient architecture was needed, and
applications began running different components in different
processes. This makes much better use of modern multi-core CPUs and
creates far safer applications. A crash in one component doesn't
affect the whole system anymore, as components are isolated on
different processes. If a process gets into an invalid state, we can
easily restart it.</p>
<p>We can also limit the blast radius of potential exploits by handing
out only the minimum amount of permissions to each process, just
enough so they can get their job done. This pattern is known as the
<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of least privilege</a>, and you see it in the real world all
the time. If you have a gardener coming over to trim your hedge, you
give them the key to your garden. You would <strong>not</strong> give them the keys
to your house; why would they need access to that? The same concept
applies to computer programs. The less access we give them, the less
harm they can do if they get compromised.</p>
<h2 id="the-core-process"><a class="header" href="#the-core-process">The Core Process</a></h2>
<p>Each Tauri application has a single core process, which acts as the
application's entry point and which is the only component with full
access to the operating system.</p>
<p>The Core's primary responsibility is to use that access to create and
orchestrate application windows, system-tray menus, or notifications.
Tauri implements the necessary cross-platform abstractions to make
this easy. It also routes all <a href="background/inter-process-communication.html">Inter-Process Communication</a> through
the Core process, allowing you to intercept, filter, and manipulate
IPC messages in one central place.</p>
<p>The Core process should also be responsible for managing global state,
such as settings or database connections. This allows you to easily
synchronize state between windows and protect your business-sensitive
data from prying eyes in the Frontend.</p>
<p>We chose Rust to implement Tauri because its concept of <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a>
guarantees memory safety while retaining excellent performance.</p>
<figure>
<pre class="mermaid">flowchart TD
    C{Core}
    W1[WebView]
    W2[WebView]
    W3[WebView]

    C &lt;--&gt;|Events &amp; Commands| W1
    C &lt;--&gt;|Events &amp; Commands| W2
    C &lt;--&gt;|Events &amp; Commands| W3
</pre>
<figcaption>Figure 1-1: Simplified representation of the Tauri process model. A single Core process manages one or more WebView processes.</figcaption>
</figure>
<h2 id="the-webview-process"><a class="header" href="#the-webview-process">The WebView Process</a></h2>
<p>The Core process doesn't render the actual user interface (UI) itself;
it spins up WebView processes that leverage WebView libraries provided
by the operating system. A WebView is a browser-like environment that
executes your HTML, CSS, and JavaScript.</p>
<p>This means that most of your techniques and tools used in traditional
web development can be used to create Tauri applications. For example,
many Tauri examples are written using the <a href="https://svelte.dev/">Svelte</a> frontend framework
and the <a href="https://vitejs.dev/">Vite</a> bundler. <br> Security best practices apply as well;
for example, you must always sanitize user input, never handle secrets
in the Frontend and ideally defer as much business logic to the Core
process as possible to keep your attack surface small.</p>
<p>Contrary to other similar solutions, the WebView libraries are <strong>not</strong>
included in your final executable but dynamically linked at
runtime<sup class="footnote-reference"><a href="#1">1</a></sup>. This makes your application <em>significantly</em> smaller, but
it also means that you need to keep platform differences in mind, just
like traditional web development.</p>
<!-- prettier-ignore -->
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Currently, Tauri uses <a href="https://docs.microsoft.com/en-us/microsoft-edge/webview2/">Microsoft Edge WebView2</a> on Windows, <a href="https://developer.apple.com/documentation/webkit/wkwebview">WKWebView</a> on
macOS and <a href="https://webkitgtk.org">webkitgtk</a> on Linux.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inter-process-communication"><a class="header" href="#inter-process-communication">Inter-Process Communication</a></h1>
<p>Inter-Process Communication (IPC) allows isolated processes to
communicate securely and is key to building more complex applications.</p>
<p>Tauri uses a particular style of Inter-Process Communication called
<a href="https://en.wikipedia.org/wiki/Message_passing#Asynchronous_message_passing">Asynchronous Message Passing</a>, where processes exchange <em>requests</em>
and <em>responses</em> serialized using some simple data representation.
Message Passing should sound familiar to anyone with web development
experience, as this paradigm is used for client-server communication
on the internet.</p>
<p>Message passing is a safer technique than shared memory or direct
function access because the recipient is free to reject or discard
requests as it sees fit. For example, if the Tauri Core process
determines a request to be malicious, it simply discards the requests
and never executes the corresponding function.</p>
<p>In the following, we explain Tauri's two IPC primitives - <code>Events</code> and
<code>Commands</code> - in more detail.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Events are fire-and-forget, one-way IPC messages that are best suited
to communicate lifecycle events and state changes. Contrary to
<a href="background/inter-process-communication.html#commands">Commands</a> Events can be emitted by both the Frontend <em>and</em>
the Tauri Core.</p>
<figure>
<pre class="mermaid">sequenceDiagram
    participant F as Frontend
    participant C as Tauri Core

    C-)F: Event
</pre>
<figcaption>Figure 1-2: An event sent from the Core to the Frontend.</figcaption>
</figure>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Tauri also provides a <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a>-like abstraction on
top IPC messages<sup class="footnote-reference"><a href="#1">1</a></sup>. The primary API, <code>invoke</code>, is similar to the
browsers <code>fetch</code> API and allows the Frontend to invoke rust functions,
pass arguments, and receive data.</p>
<p>Because this mechanism uses the <a href="https://www.jsonrpc.org">JSON-RPC</a> protocol under the hood to
serialize requests and responses, all arguments and return data must
be serializable to JSON.</p>
<figure>
<pre class="mermaid">sequenceDiagram
    participant F as Frontend
    participant C as Tauri Core

    F-)+C: IPC request
    note over C: Perform computation, write to file system, etc.
    C-)-F: Response
</pre>
<figcaption>Figure 1-3: IPC messages involved in a command invocation.</figcaption>
</figure>
<!-- prettier-ignore -->
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Commands still use message passing under the hood, so don't share the same
security pitfalls as real FFI interfaces.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Whether you like it or not, today's applications live in operating
systems that can be -- and regularly are -- compromised by any number
of attacks. When your insecure application is a gateway for such
lateral movement into the operating system, you are contributing to
the tools that professional hackers have at their disposal. Don't be a
tool.</p>
<p>This is why we have taken every opportunity to help you secure your
application, prevent undesired access to system level interfaces, and
manufacture bullet-proof applications. Your users assume you are
following best practices. We make that easy, but you should still read
up on it below.</p>
<h2 id="security-is-a-community-responsibility"><a class="header" href="#security-is-a-community-responsibility">Security Is A Community Responsibility</a></h2>
<p>It is important to remember that the security of your Tauri
application is the result of the overall security of Tauri itself, all
Rust and NPM dependencies, your code, and the devices that run the
final application. The Tauri Team does its best to do its part, the
security community does its part, and you too would do well to follow
a few important best practices:</p>
<ul>
<li>
<p><strong>Keep your application up-to-date.</strong> When releasing your app into
the wild, you are also shipping a bundle that has Tauri in it.
Vulnerabilities affecting Tauri may impact the security of your
application. By updating Tauri to the latest version, you ensure
that critical vulnerabilities are already patched and cannot be
exploited in your application. Also be sure to keep your compiler
(rustc) and transpilers (nodejs) up to date, because there are often
security issues that are resolved.</p>
</li>
<li>
<p><strong>Evaluate your dependencies.</strong> While NPM and Crates.io provide many
convenient packages, it is your responsibility to choose trustworthy
3rd-party libraries - or rewrite them in Rust. If you do use
outdated libraries affected by known vulnerabilities or are
unmaintained, your application security and good-night's sleep could
be in jeopardy. Use tooling like npm audit and cargo audit to
automate this process and lean on the security community's important
work.</p>
</li>
<li>
<p><strong>Adopt more secure coding practices.</strong> The first line of defense
for your application is your own code. Although Tauri can protect
you from common web vulnerabilities, such as Cross-Site Scripting
based Remote Code Execution, improper configurations can have a
security impact. Even if this were not the case, it is highly
recommended to adopt secure software development best practices and
perform security testing. We detail what this means in the next
section.</p>
</li>
<li>
<p><strong>Educate your Users.</strong> True security really means that unexpected
behaviour cannot happen. So in a sense, being more secure means
having the peace of mind in knowing that ONLY those things that you
want to happen can happen. In the real world, though, this is a
utopian &quot;dream&quot;. However, by removing as many vectors as possible
and building on a solid foundation, your choice for Tauri is a
signal to your users that you really care about them, their safety,
and their devices.</p>
</li>
</ul>
<h2 id="threat-models"><a class="header" href="#threat-models">Threat Models</a></h2>
<p>Tauri applications are composed of many pieces at different points of
the lifecycle. Here we describe classical threats and what you SHOULD
do about them.</p>
<ul>
<li>
<p><strong>Upstream Threats.</strong> Tauri is a direct dependency of your project,
and we maintain strict authorial control of commits, reviews, pull
requests, and releases. We do our best to maintain up-to-date
dependencies and take action to either update or fork&amp;fix. Other
projects may not be so well maintained, and may not even have ever
been audited. Please consider their health when integrating them,
because otherwise you may have adopted architectural debt without
even knowing it.</p>
</li>
<li>
<p><strong>Development Threats.</strong> We assume that you, the developer, care for
your development environment like a shrine of purity because it is a
thing of beauty. It is on you to make sure that your operating
system, build toolchains, and associated dependencies are kept up to
date.</p>
<p>A genuine risk all of us face is what is known as &quot;supply-chain
attacks&quot;, which are usually considered to be attacks on direct
dependencies of your project. However, a growing class of attacks in
the wild directly target development machines, and you would be
well-off to address this head-on. <br> One practice that we highly
recommend, is to only ever consume critical dependencies from git
using hash revisions at best or named tags as second best. This
holds for Rust as well as the Node ecosystem. Also, consider
requiring all contributors to sign their commits and protect GIT
branches and pipelines.</p>
</li>
<li>
<p><strong>Buildtime Threats.</strong> Modern organisations use CI/CD to manufacture
binary artifacts. At Tauri, we even provide a Github Workflow for
building on multiple platforms. If you create your own CI/CD and
depend on third-party tooling, be wary of actions whose versions you
have not explicitly pinned. <br> You should sign your binaries for
the platform you are shipping to, and while this can be complicated
and somewhat costly to setup, end-users expect that your app is
verifiably from you.</p>
</li>
<li>
<p><strong>Runtime Threats.</strong> We assume the webview is insecure, which has
led Tauri to implement several protections regarding webview access
to system APIs in the context of loading untrusted userland content.
<br> You can read more in detail below, but using the CSP will
lockdown types of communication that the Webview can undertake.
Furthermore, <a href="background/security/index.html#context-isolation">Context Isolation</a> prevents
untrusted content or scripts from accessing the API within the
Webview. <br> And please, whatever you do, <strong>DO NOT</strong> trust the
results of cryptography using private keys in the Webview. We gave
you Rust for a reason.</p>
</li>
<li>
<p><strong>Updater Threats.</strong> We have done our best to make shipping
hot-updates to the app as straightforward and secure as possible.
However, all bets are off if you lose control of the manifest
server, the build server, or the binary hosting service. If you
build your own system, consult a professional OPS architect and
build it properly.</p>
</li>
</ul>
<h2 id="secure-content-loading"><a class="header" href="#secure-content-loading">Secure content loading</a></h2>
<p>Tauri restricts the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy</a> (CSP) of your HTML
pages. Local scripts are hashed, styles and external scripts are
referenced using a cryptographic nonce, which prevents unallowed
content from being loaded.</p>
<blockquote>
<p>❗️ Avoid loading remote content such as scripts served over a CDN
as they introduce an attack vector, but any untrusted file can
introduce new and subtle attack vectors.</p>
</blockquote>
<p>The CSP protection is only enabled if [tauri &gt; security &gt; csp] is set
on the Tauri configuration file. You should make it as restricted as
possible, only allowing the webview to load assets from hosts you
trust and preferably own. At compile time, Tauri appends its nonces
and hashes to the relevant CSP attributes automatically, so you only
need to worry about what is unique to your application.</p>
<p>See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src"><code>script-src</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src"><code>style-src</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources">CSP Sources</a> for more
information about this protection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-isolation"><a class="header" href="#context-isolation">Context Isolation</a></h1>
<p>Context Isolation is a way to intercept and modify Tauri API messages
sent by the Frontend before they get to Tauri Core, all with
JavaScript. The secure JavaScript code that is injected by the
Isolation pattern is referred to as the Isolation application.</p>
<p>This is useful to validate, sanitize, and filter messages sent to the
front end before they even enter the Core's secure context.</p>
<h2 id="why"><a class="header" href="#why">Why?​</a></h2>
<p>The Isolation pattern's purpose is to provide a mechanism for
developers to help protect their application from unwanted or
malicious frontend calls to Tauri Core. The need for the Isolation
pattern rose out of threats coming from untrusted content running on
the Frontend, a common case for applications with many dependencies.
See <a href="background/security/security#threat-models">Security: Threat Models</a> for a list of many sources of threats
that an application may see.</p>
<p>The largest threat model described above that the Isolation pattern
was designed in mind with was Development Threats. Not only do many
frontend build-time tools consist of many dozen (or hundreds) of often
deeply-nested dependencies, but a complex application may also have a
large amount of (also often deeply-nested) dependencies that are
bundled into the final output.</p>
<h2 id="when"><a class="header" href="#when">When?</a></h2>
<p>Tauri highly recommends using the isolation patten whenever it can be
used. Because the Isolation application intercepts <em>all</em> messages from
the Frontend, it can <em>always</em> be used.</p>
<p>We highly suggest that you lock down your application whenever you use
external Tauri APIs. As the developer, you can utilize the secure
Isolation application to verify IPC inputs make sure they are within
some expected parameters. For example, you may want to check that a
call to read or write a file is not trying to get to a path outside
your application's expected locations. <br> Another example is making
sure that a Tauri API HTTP fetch call is only setting the Origin
header to what your application expects it to be.</p>
<p>That said, it intercepts all messages from the Frontend, so it will
even work with always-on APIs such as <a href="background/security/../inter-process-communication.html#events">Events</a>. Since some events may
cause your rust code to perform actions, the same validation
techniques can be used.</p>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>An Isolation Application is essentially a just JavaScript file that
Tauri will run in a locked-down, isolated environment. You assign a
callback to the <code>window.__TAURI_ISOLATION_HOOK__</code> global property that
Tauri will invoke whenever an IPC message is about to be sent.</p>
<p>Because the point of the Isolation application is to protect against
Development Threats, we highly recommend keeping your Isolation
application as simple as possible. <br> Fewer dependencies and build
steps mean less risk of supply chain attacks against your Isolation
application.</p>
<h3 id="creating-the-isolation-application"><a class="header" href="#creating-the-isolation-application">Creating the Isolation Application</a></h3>
<p>We will make a small hello-world style Isolation application and hook
it up to an imaginary existing Tauri application. It will do no
verification of the messages passing through it, only print the
contents to the WebView console.</p>
<p>For the purposes of this example, let's imagine we are in the same
directory as <code>tauri.conf.json</code>. The existing Tauri application has
it's <code>distDir</code> set to <code>../dist</code>.</p>
<p>Filename: index.html</p>
<figure>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Isolation Secure Script&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption>Listing 1-1: HTML entrypoint responsible for loading the JavaScript.</figcaption>
</figure>
<p>Filename: index.js</p>
<figure>
<pre><code class="language-javascript">window.__TAURI_ISOLATION_HOOK__ = (payload) =&gt; {
  // let's just print payload
  console.log(&quot;hook&quot;, payload);
  return payload;
};
</code></pre>
<figcaption>Listing 1-2: The main Isolation Application script.</figcaption>
</figure>
<p>We need to set up our <code>tauri.conf.json</code> configuration to enable
Context Isolation.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Let's assume that our main frontend <code>distDir</code> is set to <code>../dist</code>. We
also output the previously created Isolation application to
<code>../dist-isolation</code>.</p>
<p>Filename: tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;build&quot;: {
    &quot;distDir&quot;: &quot;../dist&quot;
  },
  &quot;tauri&quot;: {
    &quot;pattern&quot;: {
      &quot;use&quot;: &quot;isolation&quot;,
      &quot;options&quot;: {
        &quot;dir&quot;: &quot;../dist-isolation&quot;
      }
    }
  }
}
</code></pre>
<h2 id="digging-deeper"><a class="header" href="#digging-deeper">Digging Deeper</a></h2>
<p>If you want to fully understand how the Context Isolation is
implemented, so you can properly secure your application, we go into
more detail below.</p>
<figure>
<pre class="mermaid">sequenceDiagram
    autonumber

    participant F as Frontend
    participant H as Isolation Handler
    participant I as Isolation Application
    participant C as Tauri Core

    F-)H: Send Message
    H-)+I: Call the Isolation Application with Message
    I-)-H: Return sanitized Message
    note over H: Automatically encrypt sanitized Message
    H--&gt;&gt;F: Send encrypted, sanitized Message
    F--&gt;&gt;C: Send encrypted, sanitized Message
</pre>
<figcaption>Figure 1-4: Approximate Steps of an IPC Message​ being sent to Tauri Core with Context
Isolation enabled.</figcaption>
</figure>
<ol>
<li>When <code>invoke</code> is called, the Message gets sent to the Isolation
Application.</li>
<li>Pass the message into the Isolation Application's hook. The Message
object has been checked to follow the minimum correct shape.</li>
<li>The return value is used as the new Message. The Isolation
Application <em>may</em> have modified Message to help sanitize input.</li>
<li>The sanitized Message is <strong>automatically</strong> encrypted using AES-GCM
using a runtime-generated key and sent to the Frontend.</li>
<li>The encrypted, sanitized message is sent to Tauri Core; which
exclusively processes encrypted messages while Context Isolation is
enabled.</li>
</ol>
<h3 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h3>
<p>Because encryption of the message does occur, this does mean that
there are additional overhead costs even if the secure Isolation
application doesn't do anything. Most applications should not notice
the runtime costs of encrypting/decrypting the IPC messages as they
are both relatively small and AES-GCM is relatively fast. If you are
unfamiliar with AES-GCM, all that is relative in this context is that
it's the only authenticated mode algorithm included in <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">SubtleCrypto</a>
and that you probably already use it every day under the hood with
TLS.</p>
<p>There is also a cryptographically secure key generated once each time
the Tauri application is started. It is not generally noticeable if
the system already has enough entropy to immediately return enough
random numbers, which is extremely common for desktop environments. If
running in a headless environment to perform some [end-to-emd testing
with WebDriver] then you may want to install some sort of entropy
generating service such as <a href="https://www.issihosts.com/haveged/"><code>haveged</code></a> if your operating system does
not have one included.</p>
<blockquote>
<p>Linux 5.6 (March 2020) now includes entropy generation using
speculative execution. <!-- TODO: Source? --></p>
</blockquote>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>There are a few limitations with Context Isolation due to platform
inconsistencies. The most significant limitation is due to external
files not loading correctly inside sandboxed <code>iframes</code> on Windows.
Because of this, we have implemented a simple script inlining step
during build time that takes the content of scripts relative to the
Isolation application and injects them inline. This means that typical
bundling or simple including of files like
<code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code> still works properly, but newer
mechanisms such as ES Modules will not successfully load.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inter-process-communication-1"><a class="header" href="#inter-process-communication-1">Inter-Process Communication</a></h1>
<p>We established the general concepts and ideas behind IPC in
<a href="development/../understanding-tauri/inter-process-communication.html">Background: Inter-Process Communication</a>. This guide teaches you how
to put that theory to practice and interact with the IPC system from
both JavaScript and Rust.</p>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<p>Events are one-way IPC messages and come in two distinct flavors:
<em>Global Events</em> and <em>Window-specific Events</em>. Global events are
emitted for application-wide lifecycle events (e.g. update events),
while window-specific events are, as the name suggests, emitted for
window lifecycle events like resizing, moving, or user-defined events.</p>
<h2 id="commands-1"><a class="header" href="#commands-1">Commands</a></h2>
<p>At its simplest, a Command is a Rust function that is invoked in
response to an incoming IPC request. This function has access to the
application state, windows, may take input parameters, and returns
data. You can think of them almost like [Serverless Functions] that
live in the Tauri Core process and communicate over IPC.</p>
<p>To turn a Rust function into a Command, add <code>#[tauri::command]</code> to the
line before <code>fn</code>. This <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">Attribute Macro</a> wraps your function, handles
JSON serialization, and injects
<a href="development/inter-process-communication.html#special-parameters">Special Paramaters</a>.</p>
<figure>
<pre><code class="language-rust ignore">#[tauri::command]
fn my_custom_command() {
  println!(&quot;Hello, world!&quot;);
}
</code></pre>
<figcaption>
<p>Listing 2-TODO: A regular Rust function turned into a Command by the
<code>tauri::command</code> macro.</p>
</figcaption>
</figure>
<p>You can use the <code>invoke()</code> function provided by the <code>@tauri-apps/api</code>
package to call Commands from the Frontend. The function requires the
Command name and optional parameters and returns a promise that
resolves when the Command finished executing:</p>
<figure>
<pre><code class="language-javascript">import { invoke } from &quot;@tauri-apps/api&quot;;

await invoke(&quot;my_custom_command&quot;);
</code></pre>
<figcaption>Listing 2-TODO: A command invocation without parameters.</figcaption>
</figure>
<!-- TODO: register command handler -->
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Commands can have parameters, which are defined like regular Rust
function parameters. Tauri will reject IPC requests for a command if
the argument number, types, or names are invalid.</p>
<p>All parameters must implement <code>serde::Deserialize</code> so the
<code>tauri::command</code> macro can correctly parse the incoming IPC request.
Standard types such as <code>u8</code>, <code>String</code> or <code>bool</code> are deserializable by
default, but you have to <a href="https://serde.rs/derive.html">derive</a> or <a href="https://serde.rs/impl-deserialize.html">manually
implement</a> <code>serde::Deserialize</code> for
types you defined yourself.</p>
<figure>
<pre><code class="language-rust ignore">#[tauri::command]
fn my_command(msg: String) {
    println!(&quot;I was invoked with this message: {}&quot;, msg);
}
</code></pre>
<figcaption>Listing 2-TODO: Simple command accepting only a single parameter.</figcaption>
</figure>
<h4 id="special-parameters"><a class="header" href="#special-parameters">Special Parameters</a></h4>
<p>Commands that only have access to the parameters passed from the
Frontend aren't too helpful, so the <code>tauri::command</code> macro has a
couple of tricks up its sleeve. If you specify any of the following
types as parameters to your function, they will be <em>automagically</em>
injected by the macro.</p>
<ul>
<li><a href="https://docs.rs/tauri/*/tauri/struct.Window.html"><code>tauri::Window</code></a> - A handle to the window that invoked the Command.</li>
<li><a href="https://docs.rs/tauri/*/tauri/struct.AppHandle.html"><code>tauri::AppHandle</code></a> - A handle to the global <code>App</code> instance.</li>
<li><a href="https://docs.rs/tauri/*/tauri/struct.State.html"><code>tauri::State&lt;T&gt;</code></a> - Tries to inject globally
managed state <code>T</code>. This requires that you previously called
<a href="https://docs.rs/tauri/*/tauri/trait.Manager.html#method.manage"><code>manage(T)</code></a>.</li>
</ul>
<p>The <code>tauri::command</code> macro strips Special Parameters from the function
signature, so they are <em>invisible</em> to the Frontend as Listing 2-TODO
shows.</p>
<figure>
<pre><code class="language-rust ignore">#[tauri::command]
fn my_command(window: tauri::Window, _app_handle: tauri::AppHandle) {
    println!(&quot;I was invoked from window: {}&quot;, window.label());
}
</code></pre>
<pre><code class="language-javascript">invoke(&quot;my_command&quot;);
</code></pre>
<figcaption>Listing 2-TODO: Special Parameters are invisible to the Frontend.</figcaption>
</figure>
<p>You can instruct the macro to inject globally managed state by using
the <a href="https://docs.rs/tauri/*/tauri/struct.State.html"><code>tauri::State</code></a> type. This only works with types that you
previously stored in the globaly state with <a href="https://docs.rs/tauri/*/tauri/trait.Manager.html#method.manage"><code>manage()</code></a>, see the
<a href="development/state-management.html">State Management</a> guide for more details.</p>
<figure>
<pre><code class="language-rust ignore">struct DBConnection(Option&lt;DBClient&gt;);

#[tauri::command]
fn is_connected(connection: State&lt;'_, DBConnection&gt;) -&gt; bool {
    // return true if `connection` holds a `DBClient`
    connection.0.is_some()
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![is_connected])
        .setup(|app| {
            app.manage(DBConnection(None));

            Ok(())
        })
        .run()
        .expect(&quot;failed to run app&quot;);
}
</code></pre>
<figcaption>
<p>Listing 2-TODO: Using <code>State</code> to inject global application state in
commands.</p>
</figcaption>
</figure>
<blockquote>
<p><strong>Note</strong>: It's an informal convention that you put Special
Parameters before any regular Parameters.</p>
</blockquote>
<h3 id="commands-with-return-values"><a class="header" href="#commands-with-return-values">Commands with Return Values</a></h3>
<p>Commands can return values to the Frontend, exactly like regular Rust
functions, with one caveat: Return values must be representable as
JSON. In Rust we say that the type needs to implement
<code>serde::Serialize</code>.</p>
<p>Most standard types such as <code>u8</code>, <code>String</code> or <code>bool</code> already implement
<code>serde::Serialize</code> by default and even more complex types such as
<code>HashMap&lt;K,V&gt;</code> can be serialized as long as both generic types
implement <code>serde::Serialize</code>. For types that you defined yourself you
need to either <a href="https://serde.rs/derive.html">derive the trait</a> or <a href="https://serde.rs/impl-serialize.html">implement
it manually</a>.</p>
<figure>
<pre><code class="language-rust ignore">#[tauri::command]
fn simple_command() -&gt; String {
  &quot;Hello from Rust!&quot;.into()
}

#[derive(serde::Serialize)]
struct Data {
  some_key: String,
  some_other_key: bool,
  more_complex_value: HashMap&lt;String, DataInner&gt;
}

#[derive(serde::Serialize)]
struct DataInner(Vec&lt;u8&gt;);

#[tauri::command]
fn complex_command() -&gt; Data {
  let mut map = HashMap::default();

  map.insert(&quot;first&quot;, DataInner(vec![1,2,3,4]));

  Data {
    some_key: &quot;foobar&quot;.to_string(),
    some_other_key: true,
    more_complex_value: map,
  }
}
</code></pre>
<pre><code class="language-javascript">const msg = invoke(&quot;simple_command&quot;);

// prints &quot;Hello from Rust!&quot;
console.log(msg.payload);

const data = invoke(&quot;complex_command&quot;);

// prints the following:
// {
//  some_key: &quot;foobar&quot;,
//  some_other_key: true,
//  more_complex_value: {
//      first: [1,2,3,4]
//  }
// }
console.log(data.payload);
</code></pre>
<figcaption>
<p>Listing 2-TODO: Simple and complex command return values, showing how
<code>derive(Serde::Serialize)</code> can be used to return user-defined types.</p>
</figcaption>
</figure>
<h3 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h3>
<p>Rust has a standard way to represent failures in functions: The
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a> type. It is an enum with two variants, <code>Ok(T)</code>,
representing success, and <code>Err(E)</code>, representing error.</p>
<p>As you learned earlier Command invocations are represented by a
JavaScript promise. By returning a Result from your Command you can
directly influence the state of that promise: Returning <code>Ok(T)</code>
resolves the promise with the given <code>T</code>, while returning <code>Err</code> rejects
the promise with <code>E</code> as the error.</p>
<figure>
<pre><code class="language-rust ignore">#[tauri::command]
fn failing_command() -&gt; Result&lt;String, String&gt; {
  Err(&quot;oops!&quot;.to_string())
}
</code></pre>
<figcaption>Listing 2-TODO: A Command that always fails.</figcaption>
</figure>
<p>If you try this using real-world functions, however, you quickly run
into a problem: No error type implements <code>serde::Serialize</code>!</p>
<figure>
<pre><code class="language-rust ignore compile_fail">use std::fs::File;
use std::io;
use std::io::Read;

#[tauri::command]
fn read_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;

    Ok(s)
}
</code></pre>
<figcaption>
<p>Listing 2-TODO: This code does not compile because <code>std::io::Error</code> is
not serializable.</p>
</figcaption>
</figure>
<p>You could just use an error type, for example, <code>String</code> like we did in
Listing-TODO, but that is not very <em>idiomatic</em>. Instead, we create a
custom error type that implements <code>serde::Serialize</code>. <br> In the
following example, we use a crate called <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a> to help create
the error type. It allows you to turn enums into error types by
deriving the <code>thiserror::Error</code> trait. You can consult its
documentation for more details.</p>
<pre><code class="language-rust ignore">// create the error type that represents all errors possible in our program
#[derive(Debug, thiserror::Error)]
enum Error {
  #[error(transparent)]
  Io(#[from] std::io::Error)
}

// we must manually implement serde::Serialize
impl serde::Serialize for Error {
  fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
  where
    S: serde::ser::Serializer,
  {
    serializer.serialize_str(self.to_string().as_ref())
  }
}
</code></pre>
<p>A custom error type has the advantage of making all possible errors
explicit so readers can quickly identify what errors can happen. This
saves other people (and yourself) enormous amounts of time when
reviewing and refactoring code later. <br> It also gives you full
control over the way your error type gets serialized. In the above
example, we simply returned the error message as a string, but you
could assign each error a code similar to C.</p>
<h3 id="async-commands"><a class="header" href="#async-commands">Async Commands</a></h3>
<p>If your Command spends time waiting for IO - maybe it is reading a
file or connecting to a server - it blocks the main process for that
duration. This means the window becomes unresponsive, and your app
<em>freezes</em>. To avoid this problem Rust has builtin support
<em>asynchronous functions</em> through <a href="https://rust-lang.github.io/async-book/02_execution/02_future.html">the <code>Future</code> Trait</a>. A familiar
concept if you already know about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> and <code>async/await</code> in
JavaScript.</p>
<p>You declare an asynchronous command by writing <code>async fn</code> instead of
<code>fn</code>:</p>
<pre><code class="language-rust ignore">#[tauri::command]
async fn async_command() {}
</code></pre>
<p>Async Commands are executed on a thread pool using
<a href="https://docs.rs/tauri/*/tauri/async_runtime/fn.spawn.html"><code>tauri::async_runtime::spawn()</code></a>, so long-running tasks no longer
block the Core's main thread. Because Commands map to JavaScript
promises in the Frontend, they also don't block the Frontend's main
thread.</p>
<blockquote>
<p>To execute <em>non-async</em>, regular Commands on a different thread,
define the macro like so: <code>#[tauri::command(async)]</code>.</p>
</blockquote>
<p>Listing-TODO shows a more complete example that uses the non-blocking
<code>tokio::fs::read()</code> function to read a file from disk, convert it to a
Utf8 string and parse it into a Vec of lines. It also uses the
previously introduced <code>thiserror</code> and <code>serde::Serialize</code> to create a
custom Error type.</p>
<figure>
<pre><code class="language-rust ignore">use std::path::PathBuf;

// A custom error type that represents all possible in our command
#[derive(Debug, thiserror::Error)]
enum Error {
    #[error(&quot;Failed to read file: {0}&quot;)]
    Io(#[from] std::io::Error),
    #[error(&quot;File is not valid utf8: {0}&quot;)]
    Utf8(#[from] std::string::FromUtf8Error),
}

// we must also implement serde::Serialize
impl serde::Serialize for Error {
  fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
  where
    S: serde::ser::Serializer,
  {
    serializer.serialize_str(self.to_string().as_ref())
  }
}

async fn async_read_lines(path: PathBuf) -&gt; Result&lt;Vec&lt;String&gt;, Error&gt; {
    // read bytes a non-blocking way
    let bytes = tokio::fs::read(path).await?;

    // convert bytes into utf8 string
    let string = String::from_utf8(bytes)?;

    // splitting at newline characters
    let lines = string
        .split('\n')
        .map(|line| line.to_string())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    Ok(lines)
}
</code></pre>
<figcaption>Listing 2-TODO: A more complete examples that uses non-blocking APIs to read a file into a Vec of lines.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows--webviews"><a class="header" href="#windows--webviews">Windows &amp; Webviews</a></h1>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>A Tauri application consists of one or more windows that are managed
by <a href="development/../background/process-model.html#the-core-process">the Core process</a>. Each window is identified by a unique string
label that you can freely choose when creating the window. You can use
this label to retrieve a reference to a specific window later to, for
example, resize a specific window.</p>
<p>The <a href="https://docs.rs/tauri/*/tauri/async_runtime/struct.WindowBuilder.html"><code>WindowBuilder</code></a> can be used to configure and create windows with
a wide range of configurable options, as you can see in the
Listing-TODO below.</p>
<figure>
<pre><code class="language-rust ignore">fn main() {
    tauri::Builder::default()
        .setup(|app| {
            WindowBuilder::new(
                    app,
                    &quot;example_window&quot;, // the unique label
                    WindowUrl::App(&quot;index.html&quot;.into())
                )
                .title(&quot;Example Window&quot;)
                .resizable(true)
                .min_inner_size(1000,500)
                .max_inner_size(1200,700)
                .always_on_top(true)
                .build()
                .expect(&quot;failed to create example window&quot;);
        })
        .run()
        .expect(&quot;failed to run app&quot;);
}
</code></pre>
<figcaption>
<p>Listing 2-TODO: Creating a new using the <code>WindowBuilder</code> and setting
various options.</p>
</figcaption>
</figure>
<p>If you are unfamiliar with Rust programming or are looking for a
quick, no-hassle way to create windows, Tauri also supports declaring
them in the <code>tauri.conf.json</code> file.</p>
<p>Filename: tauri.conf.json</p>
<pre><code class="language-json">//...
&quot;tauri&quot;: {
    &quot;windows&quot;: [
        {
            &quot;title&quot;: &quot;Welcome to Tauri!&quot;,
            &quot;width&quot;: 800,
            &quot;height&quot;: 600,
            &quot;resizable&quot;: true,
            &quot;fullscreen&quot;: false
        }
    ],
}
//...
</code></pre>
<!-- TODO: Demonstrate window instance APIs -->
<h2 id="the-webview"><a class="header" href="#the-webview">The WebView</a></h2>
<p>Each window contains one webview that lets you render the actual UI
using HTML, CSS and JavaScript. This makes Tauri compatible with
virtually any frontend framework in existence.</p>
<p>During development you point Tauri at a localhost URL - your
development server - so that you can leverage hot module reloading
(HMR) provided by your favourite frontend build tool. <br> For
production builds however, you need to hand over static files that
Tauri will <em>inline</em> into the final binary during building. This should
feel familiar if you have build a website using a static file hosting
service like <a href="https://www.netlify.com/">Netlify</a> or <a href="https://pages.github.com/">GitHub Pages</a> before.</p>
<p>In the following examples we will be using the <a href="https://vitejs.dev">Vite</a> frontend
bundler, but you can choose any Frontend build tools that can produce
static files.</p>
<p>Filename: index.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, initial-scale=1.0&quot;
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>File tauri.conf.json</p>
<pre><code class="language-json">&quot;build&quot;: {
    // the command that will start our local development server
    &quot;beforeDevCommand&quot;: &quot;vite&quot;,
    // the localhost URL that our development server is listening on
    &quot;devPath&quot;: &quot;http://localhost:3000&quot;,
    // the command that will produce the static files during building
    &quot;beforeBuildCommand&quot;: &quot;vite build&quot;,
    // the directory where the static files will be placed by vite
    &quot;distDir&quot;: &quot;dist&quot;
}
</code></pre>
<p>As you learned <a href="development/../background/process-model.html#the-core-process">previously</a>, Tauri does ship a
webview but relies on the webviews provided by each operating system
instead. This means that not all browser APIs will be supported on all
platforms you target, WebView2 uses an evergreen updater that always
gives you the latest Chromium Features, while WKWebview versions are
tied to the macOS versions. You can refer to <a href="development/../appendix/version-tables.html">Appendix C: Version
Tables</a> to get a detailed list of macOS versions and corresponding
safari and webkit versions.</p>
<p>Don't despair however, platform differences are common in web
development (think of IE11) and there are many tools that can aid you
in writing elegant cross-platform JavaScript.</p>
<blockquote>
<p>Note: <code>ES2021</code> is supported across all Tauri platforms, so most
language features should work out-of-the-box without transpilation.</p>
</blockquote>
<ol>
<li>
<p><strong>Use a Transpiler</strong>. Transpilers like [Babel] take your modern
JavaScript and produce Code that works on older platforms,
polyfilling unsupported features in the process. If you're using
<a href="https://www.typescriptlang.org/">Typescript</a> you already have a builtin transpiler too!</p>
</li>
<li>
<p><strong>Use feature detection</strong>. Feature detection is a good practice on
the web in general, but with Tauri you can make use of several
<em>build-time</em> environment variables like <code>TAURI_PLATFORM</code> or
<code>TAURI_PLATFORM_VERSION</code> to generate platform-specific JavaScript.
These variables are exposed to the <code>beforeDevCommand</code> and
<code>beforeBuildCommand</code> by default.</p>
<figure>
Filename: vite.config.js
<pre><code class="language-javascript"> {
     // to make use of
     // `TAURI_PLATFORM`, `TAURI_ARCH`, `TAURI_FAMILY`,
     // `TAURI_PLATFORM_VERSION`, `TAURI_PLATFORM_TYPE`
     // and `TAURI_DEBUG` env variables in the Frontend
     envPrefix: [&quot;VITE_&quot;, &quot;TAURI_&quot;],
     build: {
         // tauri supports es2021
         target: [
         &quot;es2021&quot;,
         process.env.TAURI_PLATFORM === &quot;windows&quot; ? &quot;chrome97&quot; : &quot;safari13&quot;,
         ],
         // don't minify for debug builds
         minify: !process.env.TAURI_DEBUG &amp;&amp; &quot;esbuild&quot;,
         // produce sourcemaps for debug builds
         sourcemap: !!process.env.TAURI_DEBUG,
     },
 };
</code></pre>
<figcaption>
<p>Listing 2-TODO: Conditional compilation in vite using <code>TAURI_</code> environment variables.</p>
</figcaption>
</figure>
</li>
<li>
<p><strong>Use Rust</strong>. Instead of relying on features that are not supported
across all platforms you can replace them with Rust implementations
that are exposed via Commands. The <a href="https://github.com/tauri-apps/tauri-plugin-store"><code>tauri-plugin-store</code></a> is an
example of such a practice, it replaces <code>LocalStorage</code> with a much
more customizable solution written in Rust.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>With all the moving pieces in a Tauri application, chances are you
will not write perfect bug-free code all the time. Your app might
behave weirdly, be very slow, or outright crash.</p>
<p>In this guide, we give you a number of tools and techniques to
troubleshoot problems when they arise.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>To effectively debug a program, you need to know what's going on
inside. Rust and Tauri provide many tools to make this possible.</p>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>When your first learned Rust, you might have printed logging messages
by using the <code>println!</code> macro:</p>
<pre><code class="language-Rust">fn main() {
    println!(&quot;foobar&quot;);
}
</code></pre>
<p>However, for more complex projects, Rust provides an elegant logging
system that allows log messages from app code and dependencies with
different levels, timestamps, and metadata.</p>
<p>To use this system, add the <a href="https://crates.io/crates/log"><code>log</code></a> crate to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[package]
name = &quot;app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
log = &quot;0.4&quot;
</code></pre>
<p>Now you can use a number of logging macros: <a href="https://docs.rs/log/latest/log/macro.error.html"><code>error!</code></a>, <a href="https://docs.rs/log/latest/log/macro.warn.html"><code>warn!</code></a>,
<a href="https://docs.rs/log/latest/log/macro.info.html"><code>info!</code></a>, <a href="https://docs.rs/log/latest/log/macro.debug.html"><code>debug!</code></a> and <a href="https://docs.rs/log/latest/log/macro.trace.html"><code>trace!</code></a> where <code>error!</code> represents the
highest-priority log.</p>
<pre><pre class="playground"><code class="language-rust no_run">use log::{trace, debug, info, warn, error};

fn main() {
    trace!(&quot;A trace-level message&quot;);
    debug!(&quot;A debug-level message&quot;);
    info!(&quot;An info-level message&quot;);
    warn!(&quot;A warn-level message&quot;);
    error!(&quot;An error-level message&quot;);
}
</code></pre></pre>
<p>However, you will notice it doesn't actually print anything when you
run this! This is because <code>log</code> expects you to bring your own logger.
There are many available implementations to choose from, here are some
of the most popular ones:</p>
<ul>
<li>Simple minimal loggers:
<ul>
<li><a href="https://docs.rs/env_logger/*/env_logger/"><code>env_logger</code></a></li>
<li><a href="https://github.com/borntyping/rust-simple_logger"><code>simple_logger</code></a></li>
<li><a href="https://github.com/drakulix/simplelog.rs"><code>simplelog</code></a></li>
<li><a href="https://docs.rs/pretty_env_logger/*/pretty_env_logger/"><code>pretty_env_logger</code></a></li>
<li><a href="https://docs.rs/stderrlog/*/stderrlog/"><code>stderrlog</code></a></li>
<li><a href="https://docs.rs/flexi_logger/*/flexi_logger/"><code>flexi_logger</code></a></li>
</ul>
</li>
<li>Complex configurable frameworks:
<ul>
<li><a href="https://docs.rs/log4rs/*/log4rs/"><code>log4rs</code></a></li>
<li><a href="https://docs.rs/fern/*/fern/"><code>fern</code></a></li>
</ul>
</li>
</ul>
<h3 id="tauri-plugin-log"><a class="header" href="#tauri-plugin-log"><a href="https://github.com/tauri-apps/tauri-plugin-log"><code>tauri-plugin-log</code></a></a></h3>
<p>The Tauri team maintains a logger that is built explicitly for Tauri
applications. It is built on top of <a href="https://docs.rs/fern/*/fern/"><code>fern</code></a> and supports writing logs
to many different targets and consuming log messages produced in the
WebView.</p>
<p>Add it to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
log = &quot;0.4&quot;
tauri-plugin-log = { git = &quot;https://github.com/tauri-apps/tauri-plugin-log&quot; }
</code></pre>
<p>and import it like any other Tauri plugin:</p>
<figure>
<pre><pre class="playground"><code class="language-rust no_run">use tauri_plugin_log::{LogTarget, LoggerBuilder};

fn main() {
    tauri::Builder::default()
        .plugin(
            LoggerBuilder::new()
                .targets([
                    // write to the OS logs folder
                    LogTarget::LogDir,
                    // write to stdout
                    LogTarget::Stdout,
                    // forward logs to the webview
                    LogTarget::Webview,
                ])
                .build(),
        )
        .run(tauri::generate_context!())
        .expect(&quot;error while running tauri application&quot;);
}
</code></pre></pre>
<figcaption>Listing 2-TODO: Example configuration that emits logs to the WebView, Stdout and to the OS's log folder.</figcaption>
</figure>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>Sometimes simple logs are not enough to debug your problem, though, so
you might reach for the <a href="https://docs.rs/tracing/*/tracing/"><code>tracing</code></a> crate.</p>
<p>In addition to logging-style diagnostics recorded by the <a href="https://crates.io/crates/log"><code>log</code></a>
crate, it provides information about <em>temporality</em> and <em>causality</em>.
Spans in <code>tracing</code> are events that have a beginning and end time, may
be entered and exited by the flow of execution, and may exist within a
nested tree of similar spans.</p>
<pre><pre class="playground"><code class="language-rust  no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, debug, span, Level};

// records an event outside of any span context:
info!(&quot;something happened&quot;);

let span = span!(Level::INFO, &quot;my_span&quot;);
let _guard = span.enter();

// records an event within &quot;my_span&quot;.
debug!(&quot;something happened inside my_span&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="gdb"><a class="header" href="#gdb">GDB</a></h3>
<p>The <a href="https://www.sourceware.org/gdb/">GNU Project Debugger</a> (GDB) is a very old program written by
Richard Stallman in 1986. GDB has support for several languages, such
as C/C++, but also modern languages such as Go and Rust.</p>
<p><code>rust-gdb</code> comes with the Rust installation by default and is a
wrapper around GDB that enables pretty-printing rust types in the GDB
output.</p>
<p>To debug a Rust binary, build the binary:</p>
<pre><code class="language-console">cargo build --debug
</code></pre>
<p>And then load it into GDB:</p>
<pre><code class="language-console">rust-gdb target/debug/&lt;app name&gt;
</code></pre>
<h3 id="lldb"><a class="header" href="#lldb">LLDB</a></h3>
<p><a href="https://lldb.llvm.org">LLDB</a> is a debugger built on top of <a href="https://llvm.org">LLVM</a>, the compiler backend used
by Rust itself. We can use the <code>rust-lldb</code> tool, which comes with the
Rust installation by default. It wraps <a href="https://lldb.llvm.org">LLDB</a> to provide
pretty-printing rust types.</p>
<p>To debug a Rust binary, build the binary:</p>
<pre><code class="language-console">cargo build --debug
</code></pre>
<p>And then load it into LLDB:</p>
<pre><code class="language-console">rust-lldb target/debug/&lt;app name&gt;
</code></pre>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>When your Rust code runs into a problem that is <strong>so severe</strong> that it
can't recover from it, your program should <code>panic</code>. When a <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">Panic</a>
occurs, your program will print a failure message, unwind and clean up
the stack, and then quit. A <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">Panic</a> will manifest as a hard crash, so
it's crucial to minimize the number of panics.</p>
<p>To determine what caused the <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">Panic</a>, you can re-run your application
with the <code>RUST_BACKTRACE</code> environment variable set to <code>1</code> to print a
more detailed failure message.</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>To open the WebView dev tools, right-click in the WebView and choose
<code>Inspect Element</code>. This opens up the web-inspector similar to the one
you're used to from Chrome, Firefox, or Safari.</p>
<p>If you run into problems with your frontend framework, you might reach
for framework-specific dev tools. While many of them are distributed
as <em>Chromium Extensions</em>, which are <strong>not</strong> compatible with Tauri,
some of them - such as the <a href="https://devtools.vuejs.org">Vue Devtools</a> - provide standalone
versions that work nicely with Tauri.</p>
<h3 id="tauri-plugin-log-api"><a class="header" href="#tauri-plugin-log-api"><code>tauri-plugin-log-api</code></a></h3>
<p>As an alternative to the ubiquitous <code>console.log</code> debugging,
<a href="https://github.com/tauri-apps/tauri-plugin-log"><code>tauri-plugin-log</code></a> offers a JavaScript API that has a very similar
feature set to the Rust version. <br> You can install it from npm with
the following command:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install --save-dev tauri-plugin-log-api
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D tauri-plugin-log-api
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D tauri-plugin-log-api
</code></pre>
<p>Now you can emit logs using the <code>trace()</code>, <code>debug()</code>, <code>info()</code>,
<code>warn()</code> and <code>error()</code> functions and attach the devtools console to
the loggers event stream by calling <code>attachConsole()</code>:</p>
<pre><code class="language-javascript">import {
  attachConsole,
  trace,
  debug,
  info,
  warn,
  error,
} from &quot;tauri-plugin-log-api&quot;;

// with LogTarget::Webview enabled this function will print logs to the browser console
const detach = await attachConsole();

trace(&quot;A trace-level message&quot;);
debug(&quot;A debug-level message&quot;);
info(&quot;An info-level message&quot;);
warn(&quot;A warn-level message&quot;);
error(&quot;An error-level message&quot;);

// detach the webview console from the log stream
detach();
</code></pre>
<p>Please refer to <a href="https://github.com/tauri-apps/tauri-plugin-log">the plugin's documentation</a> for
details.</p>
<h2 id="debugging-production-builds"><a class="header" href="#debugging-production-builds">Debugging Production Builds</a></h2>
<p>Not all bugs are found during development; some will be reported by
your end-users. Below are some tips to help you debug production
builds.</p>
<!-- TODO: expand -->
<h3 id="tauri-plugin-log-1"><a class="header" href="#tauri-plugin-log-1">Tauri plugin log</a></h3>
<p><a href="https://github.com/tauri-apps/tauri-plugin-log"><code>tauri-plugin-log</code></a> can be used in production code too. When
configured with the <code>LogTarget::LogDir</code> it will write logs to the
canonical log-file directory of your Operating System. When your
application crashes, you can recover logs from those locations, e.g.,
the <code>Console</code> application can be used to view log files on macOS:</p>
<figure>
<picture>
  <source srcset="../img/apple_console_light.avif" type="image/avif" media="(prefers-color-scheme:light)">
  <source srcset="../img/apple_console_dark.avif" type="image/avif" media="(prefers-color-scheme:dark)">
  <source srcset="../img/apple_console_light.webp" type="image/webp" media="(prefers-color-scheme:light)">
  <source srcset="../img/apple_console_dark.webp" type="image/webp" media="(prefers-color-scheme:dark)">
  <source srcset="../img/apple_console_light.png" type="image/png" media="(prefers-color-scheme:light)">
  <source srcset="../img/apple_console_dark.png" type="image/png" media="(prefers-color-scheme:dark)">
  <img src="development/../img/a.png" alt="Apple Console App">
</picture>
<figcaption>Listing 2-TODO: Apple's Console App showing showing the Tauri app's log file.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Automated tests are essential to ensure your application's stability,
quality, and correctness. It's common to write Tests for libraries or
server-side code, but many people struggle with writing automated
tests for Graphical User Interface (GUI) applications. <br> Following
the separation of concerns you learned about in the <a href="development/../understanding-tauri/process-model.html">Process Model</a>
chapter, we recommend you set up two kinds of tests:</p>
<ul>
<li><strong>Unit Tests</strong> - Test frontend and Core functionality independently
in isolated contexts.</li>
<li><strong>End-to-End Tests</strong> (E2E) - Spiin up full instances of your app and
simulate real user interactions to make sure individually tested
components work well together.</li>
</ul>
<p>In this guide we walk you through setting up units tests for Rust and
JavaScript, as well as End-to-End tests using <a href="https://www.w3.org/TR/webdriver/">WebDriver</a>.</p>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>Unit tests verify that individual units of source code are functioning
as expected. This usually doesn't include UI (see
<a href="development/testing.html#end-to-end-tests">End-to-end Tests</a> for that) but small chunks of
internal logic, for example individual functions or methods.</p>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<p>Cargo comes with a builtin test runner - <code>cargo test</code> - that will run
unit tests and report passes and failures. The simplest test in rust
is a function with the <code>test</code> attribute. To change a plain function
into a test, add <code>#[test]</code> to the line before <code>fn</code>.</p>
<p>Since it's common to write many small tests to ensure different
expectations, Rust unit tests are commonly grouped into <em>Test
Modules</em>:</p>
<figure>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn first_test() {
        assert_eq!(2 + 2, 4);
    }

        #[test]
    fn second_test() {
        assert_eq!(4 + 4, 8);
    }
}
<span class="boring">}
</span></code></pre></pre>
<figcaption>A simplified Rust test suite containing two very basic tests.</figcaption>
</figure>
<p>The <code>#[cfg(test)]</code> attribute ensures that the module is only compiled
when running <code>cargo test</code> but stripped when you build the binary for
development or release. To learn more, see the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Conditional
Compilation</a> reference.</p>
<p>The function body uses the <code>assert_eq!</code> macro to assert that 2 + 2
equals 4 and 4 + 4 equals 8.</p>
<h3 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h3>
<p>Unit tests in JavaScript are more complicated, as there are many
competing test runners: <a href="https://jestjs.io">Jest</a>, <a href="https://mochajs.org">Mocha</a>, and <a href="https://vitest.dev">Vitest</a> are popular
choices. For the following code-snippets we will be using <a href="https://vitest.dev">Vitest</a>.</p>
<p>Contrary to Rust, where tests co-located with the source code (i.e. in
the same file), JavaScript tests are written in a separate file,
commonly named <code>*.tests.js</code>.</p>
<p>Filename: tests/main.test.ts</p>
<figure>
<pre><code class="language-typescript">import { expect, test } from &quot;vitest&quot;;
import { foo } from &quot;./main&quot;;

test(&quot;foo&quot;, () =&gt; {
  const data = foo();
  expect(data).toEqual(&quot;foo&quot;);
});
</code></pre>
<figcaption>A simplified vitest test suite containing one very basic test.</figcaption>
</figure>
<blockquote>
<p>As your tests are executed in an Isolated Context, you need to
<em>mock</em> Tauri APIs. See <a href="development/testing.html#mocking-tauri-apis">Mocking Tauri APIs</a> for
more details.</p>
</blockquote>
<p>A popular convention is to add a <code>test</code> script to your <code>package.json</code>
file, so users immediately know how to test your application. Let's
add a <code>test</code> script to our example application that just alises to the
<code>vitest</code> test runner:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;test-application&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;vitest&quot;: &quot;0.3.5&quot;
  }
}
</code></pre>
<p>Now we can run our test suite by opening a terminal and executing the
following command:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm test
</code></pre>
<pre><code class="language-console">yarn test
</code></pre>
<pre><code class="language-console">pnpm test
</code></pre>
<h2 id="end-to-end-testing"><a class="header" href="#end-to-end-testing">End-to-End Testing</a></h2>
<p>End-to-end Tests (E2E) tests simulate a user’s step-by-step
experience, testing the interactions between many components in the
process.</p>
<p><a href="https://www.w3.org/TR/webdriver/">WebDriver</a> is a standardized interface to interact with web documents
primarily intended for automated testing. It provides capabilities for
navigating to web pages, user input, JavaScript execution, and more.</p>
<p>Tauri supports the <a href="https://www.w3.org/TR/webdriver/">WebDriver</a> interface by leveraging the native
platform's <a href="https://www.w3.org/TR/webdriver/">WebDriver</a> server underneath a cross-platform wrapper
provided by <a href="https://crates.io/crates/tauri-driver"><code>tauri-driver</code></a>.</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<p>Install the latest tauri-driver or update an existing installation by
running:</p>
<pre><code class="language-console">cargo install tauri-driver
</code></pre>
<p>Because we currently utilize the platform's native <a href="https://www.w3.org/TR/webdriver/">WebDriver</a> server,
there are some requirements for running <a href="https://crates.io/crates/tauri-driver"><code>tauri-driver</code></a> on supported
platforms. Platform support is currently limited to Linux and Windows.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>We use <code>WebKitWebDriver</code> on Linux platforms. Check if this binary
exists already (command <code>which WebKitWebDriver</code>) as some distributions
bundle it with the regular WebKit package. Other platforms may have a
separate package for them, such as <code>webkit2gtk-driver</code> on Debian-based
distributions.</p>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<p>Make sure to grab the version of <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Microsoft Edge Driver</a> that matches
your Windows' Edge version that the application is being built and
tested on. This should almost always be the latest stable version on
up-to-date Windows installs. If the two versions do not match, you may
experience your WebDriver testing suite hanging while trying to
connect.</p>
<p>The download contains a binary called <code>msedgedriver.exe</code>.
<a href="https://crates.io/crates/tauri-driver"><code>tauri-driver</code></a> looks for that binary in the <code>$PATH</code> so make sure
it's either available on the path or use the --native-driver option on
<a href="https://crates.io/crates/tauri-driver"><code>tauri-driver</code></a>. You may want to download this automatically as part
of the CI setup process to ensure the Edge, and Edge Driver versions
stay in sync on Windows CI machines. A guide on how to do this may be
added at a later date.</p>
<h3 id="with-webdriverio"><a class="header" href="#with-webdriverio">With WebdriverIO</a></h3>
<p><a href="https://webdriver.io/">WebdriverIO</a> (WDIO) is a test automation framework that provides a
Node.js package for testing with WebDriver. Its ecosystem also
includes various plugins (e.g. reporter and services) that can help
you put together your test setup.</p>
<h4 id="install-the-test-runner"><a class="header" href="#install-the-test-runner">Install the test runner</a></h4>
<p>Open a terminal and run the the WebdriverIO starter toolkit in your
project with the following command:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx wdio .
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn create wdio .
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm create wdio .
</code></pre>
<p>This installs all necessary packages for you and generates a
<code>wdio.conf.js</code> configuration file.</p>
<h4 id="connect-your-tauri-app"><a class="header" href="#connect-your-tauri-app">Connect your Tauri app</a></h4>
<p>Update the <code>wdio.conf.js</code> file with the following options:</p>
<figure>
<pre><code class="language-javascript">// keep track of the `tauri-driver` child process
let tauriDriver;

exports.config = {
  // ...
  // ensure the rust project is built
  // since we expect this binary to exist
  // for the webdriver sessions
  onPrepare: () =&gt; spawnSync(&quot;cargo&quot;, [&quot;build&quot;, &quot;--release&quot;]),

  // ensure we are running `tauri-driver` before the session starts
  // so that we can proxy the webdriver requests
  beforeSession: () =&gt;
    (tauriDriver = spawn(
      path.resolve(os.homedir(), &quot;.cargo&quot;, &quot;bin&quot;, &quot;tauri-driver&quot;),
      [],
      { stdio: [null, process.stdout, process.stderr] }
    )),

  // clean up the `tauri-driver` process we spawned
  afterSession: () =&gt; tauriDriver.kill(),
  // ...
};
</code></pre>
<figcaption>Example WebdriverIO config that launches a Tauri app before tests are run and kills the app after all tests finished.</figcaption>
</figure>
<h4 id="add-tests"><a class="header" href="#add-tests">Add tests</a></h4>
<p>Let's add a test file and a couple e2e tests to show what WDIO is
capabable of. The test runner will load these files and autimatically
run them.</p>
<p>Filename: test/specs/example.e2e.js</p>
<figure>
<pre><code class="language-javascript">// calculates the luma from a hex color `#abcdef`
function luma(hex) {
  if (hex.startsWith(&quot;#&quot;)) {
    hex = hex.substring(1);
  }

  const rgb = parseInt(hex, 16);
  const r = (rgb &gt;&gt; 16) &amp; 0xff;
  const g = (rgb &gt;&gt; 8) &amp; 0xff;
  const b = (rgb &gt;&gt; 0) &amp; 0xff;
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

describe(&quot;Hello Tauri&quot;, () =&gt; {
  it(&quot;should be cordial&quot;, async () =&gt; {
    const header = await $(&quot;body &gt; h1&quot;);
    const text = await header.getText();

    expect(text).toMatch(/^[hH]ello/);
  });

  it(&quot;should be excited&quot;, async () =&gt; {
    const header = await $(&quot;body &gt; h1&quot;);
    const text = await header.getText();

    expect(text).toMatch(/!$/);
  });

  it(&quot;should be easy on the eyes&quot;, async () =&gt; {
    const body = await $(&quot;body&quot;);
    const backgroundColor = await body.getCSSProperty(
      &quot;background-color&quot;
    );

    expect(luma(backgroundColor.parsed.hex)).toBeLessThan(100);
  });
});
</code></pre>
<figure>Listing 2-TODO: An example test suite using WebdriverIO that asserts various DOM properties.</figure>
</figure>
<p>The <code>luma</code> function on top is just a helper function for one of our
tests and is not related to the actual testing of the application. If
you are familiar with other testing frameworks, you may notice similar
functions being exposed that are used, such as <code>describe</code>, <code>it</code>, and
<code>expect</code>. The other APIs, such as items like <code>$</code> and its exposed
methods, are covered by the <a href="https://webdriver.io/docs/api">WebdriverIO API docs</a>.</p>
<h4 id="run-your-tests"><a class="header" href="#run-your-tests">Run your tests</a></h4>
<p>To run your test suite, open a terminal and execute the following
command:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx wdio run wdio.conf.json
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn wdio run wdio.conf.json
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm wdio run wdio.conf.json
</code></pre>
<p>You should see the following output:</p>
<figure>
<pre><code class="language-text">➜  webdriverio git:(main) ✗ yarn test
yarn run v1.22.11
$ wdio run wdio.conf.js

Execution of 1 workers started at 2021-08-17T08:06:10.279Z

[0-0] RUNNING in undefined - /test/specs/example.e2e.js
[0-0] PASSED in undefined - /test/specs/example.e2e.js

 &quot;spec&quot; Reporter:
------------------------------------------------------------------
[wry 0.12.1 linux #0-0] Running: wry (v0.12.1) on linux
[wry 0.12.1 linux #0-0] Session ID: 81e0107b-4d38-4eed-9b10-ee80ca47bb83
[wry 0.12.1 linux #0-0]
[wry 0.12.1 linux #0-0] » /test/specs/example.e2e.js
[wry 0.12.1 linux #0-0] Hello Tauri
[wry 0.12.1 linux #0-0]    ✓ should be cordial
[wry 0.12.1 linux #0-0]    ✓ should be excited
[wry 0.12.1 linux #0-0]    ✓ should be easy on the eyes
[wry 0.12.1 linux #0-0]
[wry 0.12.1 linux #0-0] 3 passing (244ms)
</code></pre>
<figcaption>Listing 2-TODO: Example output from WebdriverIO showing the 3 tests from earlier passing.</figcaption>
</figure>
<h3 id="with-selenium"><a class="header" href="#with-selenium">With Selenium</a></h3>
<p><a href="https://www.selenium.dev/">Selenium</a> is a web automation framework that exposes bindings to
WebDriver APIs in many languages. Their Node.js bindings are available
under the <code>selenium-webdriver</code> package on NPM. Unlike the <a href="https://tauri.studio/docs/testing/webdriver/example/webdriverio#config">WebdriverIO
Test Suite</a>, Selenium does not come out of the box with a Test Suite
and leaves it up to the developer to provide one. We chose <a href="https://mochajs.org">Mocha</a> for
this example, since it's a popular choice.</p>
<h4 id="install-the-test-runner-1"><a class="header" href="#install-the-test-runner-1">Install the test runner</a></h4>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install mocha chai selenium-webdriver
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D mocha chai selenium-webdriver
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D mocha chai selenium-webdriver
</code></pre>
<h4 id="connect-your-tauri-app-1"><a class="header" href="#connect-your-tauri-app-1">Connect your Tauri app</a></h4>
<p>The following code will start an instance of your app before tests are
run and ensure the instance is terminated afterwards. Let's add it to
the default mocha testing file:</p>
<p>Filename: test/test.js</p>
<figure>
<pre><code class="language-javascript">const os = require(&quot;os&quot;);
const path = require(&quot;path&quot;);
const { spawn, spawnSync } = require(&quot;child_process&quot;);
const { Builder, By, Capabilities } = require(&quot;selenium-webdriver&quot;);

// create the path to the expected application binary
const application = path.resolve(
  __dirname,
  &quot;..&quot;,
  &quot;..&quot;,
  &quot;..&quot;,
  &quot;target&quot;,
  &quot;release&quot;,
  &quot;hello-tauri-webdriver&quot;
);

// keep track of the webdriver instance we create
let driver;

// keep track of the tauri-driver process we start
let tauriDriver;

before(async function () {
  // set timeout to 2 minutes
  // to allow the program to build if it needs to
  this.timeout(120000);

  // ensure the program has been built
  spawnSync(&quot;cargo&quot;, [&quot;build&quot;, &quot;--release&quot;]);

  // start tauri-driver
  tauriDriver = spawn(
    path.resolve(os.homedir(), &quot;.cargo&quot;, &quot;bin&quot;, &quot;tauri-driver&quot;),
    [],
    { stdio: [null, process.stdout, process.stderr] }
  );

  const capabilities = new Capabilities();
  capabilities.set(&quot;tauri:options&quot;, { application });
  capabilities.setBrowserName(&quot;wry&quot;);

  // start the webdriver client
  driver = await new Builder()
    .withCapabilities(capabilities)
    .usingServer(&quot;http://localhost:4444/&quot;)
    .build();
});

after(async function () {
  // stop the webdriver session
  await driver.quit();

  // kill the tauri-driver process
  tauriDriver.kill();
});
</code></pre>
<figcaption>Listing 2-TODO: Example Selenium file that launches a Tauri app before tests are run and kills the app after all tests finished.</figcaption>
</figure>
<h3 id="add-tests-1"><a class="header" href="#add-tests-1">Add tests</a></h3>
<p>Now we can add tests to the file we created earlier. We will be using
assertion functions provided by <a href="https://www.chaijs.com">Chai</a> such as <code>expect</code> to validate
our app works as expected.</p>
<p>Filename: test/test.js</p>
<figure>
<pre><code class="language-javascript">const { expect } = require(&quot;chai&quot;);

describe(&quot;Hello Tauri&quot;, () =&gt; {
  it(&quot;should be cordial&quot;, async () =&gt; {
    const text = await driver
      .findElement(By.css(&quot;body &gt; h1&quot;))
      .getText();

    expect(text).to.match(/^[hH]ello/);
  });

  it(&quot;should be excited&quot;, async () =&gt; {
    const text = await driver
      .findElement(By.css(&quot;body &gt; h1&quot;))
      .getText();

    expect(text).to.match(/!$/);
  });

  it(&quot;should be easy on the eyes&quot;, async () =&gt; {
    // selenium returns color css values as rgb(r, g, b)
    const text = await driver
      .findElement(By.css(&quot;body&quot;))
      .getCssValue(&quot;background-color&quot;);

    const rgb = text.match(
      /^rgb\((?&lt;r&gt;\d+), (?&lt;g&gt;\d+), (?&lt;b&gt;\d+)\)$/
    ).groups;

    expect(rgb).to.have.all.keys(&quot;r&quot;, &quot;g&quot;, &quot;b&quot;);

    const luma = 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
    expect(luma).to.be.lessThan(100);
  });
});
</code></pre>
<figcaption>Listing 2-TODO: Example tests using Selenium and Chai to assert various DOM properties.</figcaption>
</figure>
<p>If you are familiar with JS testing frameworks, <code>describe</code>, <code>it</code>, and
<code>expect</code> should look familiar. We also have semi-complex <code>before()</code>
and <code>after()</code> callbacks to setup and teardown mocha. If you compare
this to the <a href="development/testing.html#with-webdriverio">WebdriverIO example</a>, you notice a lot
more code that isn't tests, as we have to set up a few more WebDriver
related items.</p>
<h3 id="run-your-tests-1"><a class="header" href="#run-your-tests-1">Run your tests</a></h3>
<p>To run your test suite, open a terminal and execute the following
command:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npx mocha
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn mocha
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm mocha
</code></pre>
<p>We should see output the following output:</p>
<figure>
<pre><code class="language-text">➜  selenium git:(main) ✗ yarn test
yarn run v1.22.11
$ Mocha


  Hello Tauri
    ✔ should be cordial (120ms)
    ✔ should be excited
    ✔ should be easy on the eyes


  3 passing (588ms)

Done in 0.93s.
</code></pre>
<figcaption>Listing 2-TODO: Output from Selenium showing the 3 earlier tests passing.</figcaption>
</figure>
<h2 id="mocking-tauri-apis"><a class="header" href="#mocking-tauri-apis">Mocking Tauri APIs</a></h2>
<p>When writing your frontend tests, having a &quot;fake&quot; Tauri environment to
simulate windows or intercept IPC calls is common, so-called
<em>mocking</em>. The <a href="development/../api/js/modules/mocks.html"><code>@tauri-apps/api/mocks</code></a> module provides some helpful
tools to make this easier for you:</p>
<blockquote>
<p>Remember to clear mocks after each test run to undo mock state
changes between runs! See <a href="development/../api/js/modules/mocks.html#clearmocks"><code>clearMocks()</code></a> docs for more info.</p>
</blockquote>
<h3 id="ipc-requests"><a class="header" href="#ipc-requests">IPC Requests</a></h3>
<p>Most commonly, you want to intercept IPC requests; this can be helpful
in a variety of situations:</p>
<ul>
<li>Ensure the correct backend calls are made</li>
<li>Simulate different results from backend functions</li>
</ul>
<p>Tauri provides the mockIPC function to intercept IPC requests. You can
find more about the specific API in detail <a href="development/../api/js/modules/mocks.html#mockipc">here</a>.</p>
<blockquote>
<p>The following examples use <a href="https://vitest.dev">Vitest</a>, but you can use any other
frontend testing library such as jest.</p>
</blockquote>
<figure>
<pre><code class="language-javascript">import { beforeAll, expect, test } from &quot;vitest&quot;;
import { randomFillSync } from &quot;crypto&quot;;

import { mockIPC } from &quot;@tauri-apps/api/mocks&quot;;
import { invoke } from &quot;@tauri-apps/api/tauri&quot;;

// jsdom doesn't come with a WebCrypto implementation
beforeAll(() =&gt; {
  window.crypto = {
    getRandomValues: function (buffer) {
      return randomFillSync(buffer);
    },
  };
});

test(&quot;invoke simple&quot;, async () =&gt; {
  mockIPC((cmd, args) =&gt; {
    // simulate rust command called &quot;add&quot;
    if (cmd === &quot;add&quot;) {
      return args.a + args.b;
    }
  });

  expect(invoke(&quot;add&quot;, { a: 12, b: 15 })).resolves.toBe(27);
});
</code></pre>
<figcaption>Listing 2-TODO: Vitest test file showing a mocked command handler that simulates a simple add function.</figcaption>
</figure>
<p>Sometimes you want to track more information about an IPC call; how
many times was the command invoked? Was it invoked at all? You can use
<a href="development/../api/js/modules/mocks.html#mockipc"><code>mockIPC()</code></a> with other spying and mocking tools to test this:</p>
<figure>
<pre><code class="language-javascript">import { beforeAll, expect, test, vi } from &quot;vitest&quot;;
import { randomFillSync } from &quot;crypto&quot;;

import { mockIPC } from &quot;@tauri-apps/api/mocks&quot;;
import { invoke } from &quot;@tauri-apps/api/tauri&quot;;

// jsdom doesn't come with a WebCrypto implementation
beforeAll(() =&gt; {
  //@ts-ignore
  window.crypto = {
    getRandomValues: function (buffer) {
      return randomFillSync(buffer);
    },
  };
});

test(&quot;invoke&quot;, async () =&gt; {
  mockIPC((cmd, args) =&gt; {
    // simulate rust command called &quot;add&quot;
    if (cmd === &quot;add&quot;) {
      return args.a + args.b;
    }
  });

  // we can use the spying tools provided by vitest
  // to track the mocked function
  const spy = vi.spyOn(window, &quot;__TAURI_IPC__&quot;);

  expect(invoke(&quot;add&quot;, { a: 12, b: 15 })).resolves.toBe(27);
  expect(spy).toHaveBeenCalled();
});
</code></pre>
<figcaption>
<p>Listing 2-TODO: The mocked <code>__TAURI_IPC__</code> is compatible with existing
testing tools.</p>
</figcaption>
</figure>
<h3 id="windows-2"><a class="header" href="#windows-2">Windows</a></h3>
<p>Sometimes you have window-specific code (a splash screen window, for
example), so you need to simulate different windows. You can use the
<a href="development/../api/js/modules/mocks.html#mockwindows"><code>mockWindows()</code></a> method to create fake window labels. The first
string identifies the &quot;current&quot; window (i.e., the window your
JavaScript believes itself in), and all other strings are treated as
additional windows.</p>
<blockquote>
<p><a href="development/../api/js/modules/mocks.html#mockwindows"><code>mockWindows()</code></a> only fakes the existence of windows but no window
properties. To simulate window properties, you need to intercept the
correct calls using <a href="development/../api/js/modules/mocks.html#mockipc"><code>mockIPC()</code></a></p>
</blockquote>
<figure>
<pre><code class="language-javascript">import { beforeAll, expect, test } from &quot;vitest&quot;;
import { randomFillSync } from &quot;crypto&quot;;

import { mockWindows } from &quot;@tauri-apps/api/mocks&quot;;

// jsdom doesn't come with a WebCrypto implementation
beforeAll(() =&gt; {
  //@ts-ignore
  window.crypto = {
    getRandomValues: function (buffer) {
      return randomFillSync(buffer);
    },
  };
});

test(&quot;invoke&quot;, async () =&gt; {
  mockWindows(&quot;main&quot;, &quot;second&quot;, &quot;third&quot;);

  const { getCurrent, getAll } = await import(
    &quot;@tauri-apps/api/window&quot;
  );

  expect(getCurrent()).toHaveProperty(&quot;label&quot;, &quot;main&quot;);
  expect(getAll().map((w) =&gt; w.label)).toEqual([
    &quot;main&quot;,
    &quot;second&quot;,
    &quot;third&quot;,
  ]);
});
</code></pre>
<figcaption>Listing 2-TODO: A vitest test file with 3 mocked windows.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-machines"><a class="header" href="#virtual-machines">Virtual Machines</a></h1>
<p>Tauri allows you to create cross-platform applications from a single
codebase with ease.<br> This, however, doesn't mean you can just
package a Website with Tauri and be good to go. Your end-users may run
a number of Operating Systems (OS) on a wide variety of hardware. And
they all expect your app to run well on their machine, &quot;feel native&quot;
and integrate with OS features.</p>
<p>Here is where Virtual Machines (VMs) come into play: They can simulate
a variety of CPU architectures, Peripherals and run any Operating
System right from the convenience of your main development machine.
This allows you to switch between different Operating Systems very
quickly, to test and develop features and them.</p>
<p>The following picture shows a Windows 10, Windows 11, Ubuntu and macOS
VM running inside a macOS host through <a href="https://mac.getutm.app">UTM</a> a VM software for macOS.</p>
<figure>
  <picture>
    <source srcset="../img/vms.avif" type="image/avif">
    <source srcset="../img/vms.webp" type="image/webp">
    <img src="development/../img/vms.png" alt="Windows 10, Windows 11, Ubuntu and macOS VM windows">
  </picture>
<figcaption>Listing 2-TODO: Windows 10, Windows 11, Ubuntu and macOS VMs running inside a macOS host through [UTM] a VM software for macOS.</figcaption>
</figure>
<h2 id="vm-software"><a class="header" href="#vm-software">VM Software</a></h2>
<p>There are many Virtual Machine Solutions available; most of them are
free and Open-Source with some paid solutions. <br> And since giving
detailed guides for each would blow the scope of this document, we
give you a shortlist of popular projects below and invite you to read
their respective documentation for more details.</p>
<ul>
<li>
<p><a href="https://www.virtualbox.org"><strong>VirtualBox</strong></a> Popular open-source VM software
developed by Oracle.</p>
</li>
<li>
<p><a href="https://www.vmware.com"><strong>VMware</strong></a> Paid VM software for Windows with a
feature-limited free version.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/about/"><strong>Hyper-V</strong></a> Hardware virtualization technology built into
Windows itself.</p>
</li>
<li>
<p><a href="https://www.qemu.org"><strong>QEMU</strong></a> Open-source virtualization and emulation software
predominantly on Linux and macOS.</p>
</li>
<li>
<p><a href="https://mac.getutm.app"><strong>UTM</strong></a> Easy to use virtualization and emulation on macOS
using Apple Silicon features to run at near native speeds. Uses QEMU
under the hood.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-application"><a class="header" href="#building-your-application">Building your Application</a></h1>
<p>The Tauri bundler is part of the Tauri CLI and lets you compile your
binary, package assets, and prepare a final bundle with a single
command:</p>
<pre><code class="language-console">tauri build
</code></pre>
<p>Like the <code>tauri dev</code> command, the first time you run this, it takes
some time to collect the Rust crates and build everything - but on
subsequent runs, it only needs to rebuild your app's code, which is
much quicker. Besides compiling the Rust project, the <code>tauri build</code>
command does several other things for you:</p>
<ol>
<li>
<p><strong>Build the Frontend</strong></p>
<p>If you have configured your <code>tauri.conf.json</code> correctly, the
bundler calls the <br> <code>beforeBuildCommand</code> during this step,
allowing you to build your Frontend.</p>
</li>
<li>
<p><strong>Build the Rust Binary</strong></p>
<p>The bundler calls <code>cargo build</code> under the hood and compile the Rust
project into a single executable. This step also <em>inlines</em> your
previously generated Frontend files into the executable. The
compiled executable is placed in the <code>src-tauri/target/release</code>
folder.</p>
</li>
<li>
<p><strong>Create Packages</strong></p>
<p>During this step the bundler collects all necessary files for
packaging: the binary, <a href="building//docs/api/config#tauri.bundle.resources">resources</a>, <a href="building//docs/api/config#tauri.bundle.externalBin">sidecars</a>, <a href="building/icons.html">icons</a> and app
manifests. These files will be packaged up according to the package
formats your operating system supports. The created artifacts are
located in the <code>src-tauri/target/release/bundle/</code> folder.</p>
</li>
<li>
<p><strong>Code Sign</strong></p>
<p>If you have code-signing enabled, either for
<a href="building/../distribution/windows.html#code-signing">Windows</a>, <a href="building/../distributing/macos.html#code-signing">macOS</a>, or
the <a href="building/../distributing/updater.html#signing-updates">Updater</a>, the last step is signing the
created artifacts. This step will create <code>.sig</code> files in the
<code>src-tauri/target/release/bundle/</code> for each supported packaging
format.</p>
</li>
</ol>
<h2 id="packaging-formats"><a class="header" href="#packaging-formats">Packaging Formats</a></h2>
<p>It will detect your operating system and build a bundle accordingly.
It currently supports:</p>
<ul>
<li>Windows: <code>.exe</code>, <code>.msi</code>, <code>.msi.zip</code> (updater)</li>
<li>macOS: <code>.app</code>, <code>.dmg</code>, <code>.app.tar.gz</code> (updater)</li>
<li>Linux: <code>.deb</code>, <code>.AppImage</code>, <code>.AppImage.tar.gz</code> (updater)</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>There are a number of config options that change how the build process
works. For configuring the platform-specific packages, see <a href="building/windows-installer.html">Building:
Windows Installer</a>, <a href="building/macos-bundle.html">Building: macOS Bundle</a>, <a href="building/linux.html">Building: Linux</a> and
<a href="building/updater-artifacts.html">Building: Updater Artifacts</a> respectively.</p>
<h3 id="tauribundleactive"><a class="header" href="#tauribundleactive"><a href="building//docs/api/config#tauri.bundle.active"><code>tauri.bundle.active</code></a></a></h3>
<p>Set to false to disable the bundling process. This will still compile
the Rust project, but not produce any platform-specific packages.</p>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<p>Resources are configured by the <a href="building//docs/api/config#tauri.bundle.resources"><code>tauri.bundle.resources</code></a> property
and are a convenient way to include files or folders that should not
be inlined into the executable but kept on the filesystem. A common
use case is supporting files for sidecars or images or videos.</p>
<h2 id="cross-platform-compilation"><a class="header" href="#cross-platform-compilation">Cross-Platform Compilation</a></h2>
<p>Cross-platform compilation is not supported at this moment. If you
want to produce binaries for all three operating systems, you can use
<a href="building/../development/vms.html">Virtual Machines</a> or a CI service like GitHub Actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-1"><a class="header" href="#linux-1">Linux</a></h1>
<p>Tauri applications for Linux are distributed either as <a href="https://wiki.debian.org/Packaging">Debian
Packages</a> (<code>.deb</code>) or <a href="https://appimage.org/">AppImages</a>
(<code>.AppImage</code>). This guides provides information about format specific
quirks and customization opportunities.</p>
<h2 id="appimage"><a class="header" href="#appimage">AppImage</a></h2>
<p>AppImage is a distribution format that does not rely on the system
installed packages and instead bundles all dependencies and files
needed by the application. For this reason, the output file is larger
but easier to distribute since it is supported on many Linux
distributions and can be executed without installation, just making
the file executable (<code>chmod a+x MyProject.AppImage</code>) and running it
(<code>./MyProject.AppImage</code>).</p>
<p>AppImages are convenient, simplifying the distribution process if you
cannot make a package targeting the distribution's package manager.
Still, you should carefully use it as the file size grows from the
2-6MBs range to 70+MBs.</p>
<h2 id="debian-package"><a class="header" href="#debian-package">Debian Package</a></h2>
<p>Debian packages are a compressed collection of files installed on
various Linux distributions. Unlike AppImages they don't bundle
required libraries, relying instead on the correct dependency versions
installed on the system. This makes them less portable and reliable
since missing libraries or incompatible versions will cause problems.
Debian packages are recommended only for distributions that have no
support for AppImages.</p>
<h3 id="bootstrapper"><a class="header" href="#bootstrapper">Bootstrapper</a></h3>
<p>Instead of launching the app directly, you can configure the bundled
app to run a script that tries to expose the environment variables to
the app; without that, you'll have trouble using system programs
because the <code>PATH</code> environment variable isn't correct. You can enable
it with the <a href="https://tauri.studio/docs/api/config/#tauri.bundle.deb.useBootstrapper"><code>tauri.bundle.deb.useBootstrapper</code></a> config.</p>
<h3 id="additional-files"><a class="header" href="#additional-files">Additional Files</a></h3>
<p>The Debian package allows you to specify additional files that copied
to the the user's filesystem upon installation. The configuration
object maps</p>
<figure>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;deb&quot;: {
        &quot;files&quot;: {
          // copies the README.md file to /usr/lib/README.md
          &quot;/usr/lib/README.md&quot;: &quot;../README.md&quot;,
          // copies the entire public directory to /usr/lib/assets
          &quot;usr/lib/assets&quot;: &quot;../public/&quot;
        }
      }
    }
  }
}
</code></pre>
<figcaption>Listing 3-TODO: </figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-installer"><a class="header" href="#windows-installer">Windows Installer</a></h1>
<p>Tauri applications for Windows are distributed as Microsoft Installer
(<code>.msi</code> files). The Tauri CLI bundles your application binary and
additional resources in this format if you build on windows. This
guide provides information about available customization options for
the installer.</p>
<h2 id="32-bit-windows"><a class="header" href="#32-bit-windows">32-bit Windows</a></h2>
<p>The Tauri CLI compiles your executable using your machine's
architecture by default. Assuming that you're developing on a 64-bit
machine, the CLI will produce 64-bit applications. If you need to
support 32-bit machines, you can compile your application with a
different <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Rust target</a> using the <code>--target</code> flag:</p>
<figure>
<!-- TODO make powershell -->
<pre><code class="language-console">tauri build --target i686-pc-windows-msvc
</code></pre>
<figcaption>Listing 3-TODO: Building a Tauri application for 32-bit windows.</figcaption>
</figure>
<p>By default Rust only installs toolschains for your machine's target,
so you need to install the 32-bit Windows toolchain first:
<code>rustup target add i686-pc-windows-msvc</code>. You can get a full list of
Rust targets by running <code>rustup target list</code>.</p>
<h2 id="using-a-fixed-version-of-the-webview2-runtime"><a class="header" href="#using-a-fixed-version-of-the-webview2-runtime">Using a Fixed Version of the Webview2 Runtime</a></h2>
<p>By default, the Tauri installer downloads and installs the Webview2
Runtime if it is not already installed (On Windows 11, WebView2 is
preinstalled).</p>
<blockquote>
<p>You can remove the Webview2 Runtime download check from the
installer by setting <a href="building//docs/api/config/#tauri.bundle.windows.wix.skipWebviewInstall"><code>tauri.bundle.windows.wix.skipWebviewInstall</code></a>
to <code>true</code>. Your application WON'T work if the user does not have the
runtime installed.</p>
</blockquote>
<p>Using a global installation of WebView2 is great for security as
Window keeps it updated, but if your end-users have no internet
connection or you need a particular version of WebView2, Tauri can
bundle the runtime files for you. Keep in mind, that this increases
the size of windows installers by <strong>150MB</strong> since your app will
include its own copy of chromium.</p>
<ol>
<li>
<p>Download the Webview2 fixed version runtime from the <a href="https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section">official
website</a>, a <code>.cab</code> file for the
selected architecture. In this example, the downloaded filename is
<br> <code>Microsoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64.cab</code></p>
</li>
<li>
<p>Extract the file to the core folder: <br>
<code>Expand .\Microsoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64.cab -F:* ./src-tauri</code></p>
</li>
<li>
<p>Configure the Webview2 runtime path on <code>tauri.conf.json</code>:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;windows&quot;: {
        &quot;webviewFixedRuntimePath&quot;: &quot;./Microsoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64/&quot;
      }
    }
  }
}
</code></pre>
</li>
<li>
<p>Run <code>tauri build</code> to produce the Windows Installer with the fixed
Webview2 runtime.</p>
</li>
</ol>
<h2 id="customizing-the-installer"><a class="header" href="#customizing-the-installer">Customizing the Installer</a></h2>
<p>The Windows Installer package is built using the <a href="https://wixtoolset.org/documentation/manual/v3/">WiX Toolset v3</a>.
Currently, you can change it by using a custom WiX source code (an XML
file with a <code>.wxs</code> file extension) or through WiX fragments.</p>
<h3 id="replacing-the-installer-code-with-a-custom-wix-file"><a class="header" href="#replacing-the-installer-code-with-a-custom-wix-file">Replacing the Installer Code with a Custom WiX File</a></h3>
<p>The Windows Installer XML defined by Tauri is configured to work for
the common use case of simple webview-based applications; you can find
it <a href="https://github.com/tauri-apps/tauri/blob/dev/tooling/bundler/src/bundle/windows/templates/main.wxs">here</a>. It uses <a href="https://docs.rs/handlebars/latest/handlebars/">handlebars</a> so the Tauri CLI
can brand your installer according to your <code>tauri.conf.json</code>
definition. If you need a completely different installer, a custom
template file can be configured on
<a href="building//docs/api/config/#tauri.bundle.windows.wix.template"><code>tauri.bundle.windows.wix.template</code></a>.</p>
<h3 id="extending-the-installer-with-wix-fragments"><a class="header" href="#extending-the-installer-with-wix-fragments">Extending the Installer with WiX Fragments</a></h3>
<p>A <a href="https://wixtoolset.org/documentation/manual/v3/xsd/wix/fragment.html">WiX fragment</a> is a container where you can configure almost
everything offered by WiX. In this example, we will define a fragment
that writes two registry entries:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&gt;
  &lt;Fragment&gt;
    &lt;!-- these registry entries should be installed
		 to the target user's machine --&gt;
    &lt;DirectoryRef Id=&quot;TARGETDIR&quot;&gt;
      &lt;!-- groups together the registry entries to be installed --&gt;
      &lt;!-- Note the unique `Id` we provide here --&gt;
      &lt;Component Id=&quot;MyFragmentRegistryEntries&quot; Guid=&quot;*&quot;&gt;
        &lt;!-- the registry key will be under
			 HKEY_CURRENT_USER\Software\MyCompany\MyApplicationName --&gt;
        &lt;!-- Tauri uses the second portion of the
			 bundle identifier as the `MyCompany` name
			 (e.g. `tauri-apps` in `com.tauri-apps.test`)  --&gt;
        &lt;RegistryKey
          Root=&quot;HKCU&quot;
          Key=&quot;Software\MyCompany\MyApplicationName&quot;
          Action=&quot;createAndRemoveOnUninstall&quot;
        &gt;
          &lt;!-- values to persist on the registry --&gt;
          &lt;RegistryValue
            Type=&quot;integer&quot;
            Name=&quot;SomeIntegerValue&quot;
            Value=&quot;1&quot;
            KeyPath=&quot;yes&quot;
          /&gt;
          &lt;RegistryValue Type=&quot;string&quot; Value=&quot;Default Value&quot; /&gt;
        &lt;/RegistryKey&gt;
      &lt;/Component&gt;
    &lt;/DirectoryRef&gt;
  &lt;/Fragment&gt;
&lt;/Wix&gt;
</code></pre>
<p>Save the fragment file with the <code>.wxs</code> extension somewhere in your
project and reference it on <code>tauri.conf.json</code>:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;windows&quot;: {
        &quot;wix&quot;: {
          &quot;fragmentPaths&quot;: [&quot;./path/to/registry.wxs&quot;],
          &quot;componentRefs&quot;: [&quot;MyFragmentRegistryEntries&quot;]
        }
      }
    }
  }
}
</code></pre>
<p>Note that <code>ComponentGroup</code>, <code>Component</code>, <code>FeatureGroup</code>, <code>Feature</code> and
<code>Merge</code> element ids must be referenced on the <code>wix</code> object of
<code>tauri.conf.json</code> on the <code>componentGroupRefs</code>, <code>componentRefs</code>,
<code>featureGroupRefs</code>, <code>featureRefs</code> and <code>mergeRefs</code> respectively in
order to be included on the installer.</p>
<h2 id="internationalization"><a class="header" href="#internationalization">Internationalization</a></h2>
<p>The Windows Installer is built using the <code>en-US</code> language by default.
Internationalization (i18n) can be configured using the
<a href="building//docs/api/config/#tauri.bundle.windows.wix.language"><code>tauri.bundle.windows.wix.language</code></a> property, defining the languages
Tauri should build an installer against. You can find the language
names to use in the Language-Culture column
<a href="https://docs.microsoft.com/en-us/windows/win32/msi/localizing-the-error-and-actiontext-tables">here</a>.</p>
<h3 id="compiling-an-installer-for-a-single-language"><a class="header" href="#compiling-an-installer-for-a-single-language">Compiling an Installer for a single Language</a></h3>
<p>To create a single installer targeting a specific language, set the
<code>language</code> value to a string:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;windows&quot;: {
        &quot;wix&quot;: {
          &quot;language&quot;: &quot;fr-FR&quot;
        }
      }
    }
  }
}
</code></pre>
<h3 id="compiling-an-installer-for-each-language-in-a-list"><a class="header" href="#compiling-an-installer-for-each-language-in-a-list">Compiling an Installer for each Language in a List</a></h3>
<p>To compile an installer targeting a list of languages, use an array. A
specific installer for each language will be created, with the
language key as a suffix:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;windows&quot;: {
        &quot;wix&quot;: {
          &quot;language&quot;: [&quot;en-US&quot;, &quot;pt-BR&quot;, &quot;fr-FR&quot;]
        }
      }
    }
  }
}
</code></pre>
<h3 id="configuring-the-installer-for-each-language"><a class="header" href="#configuring-the-installer-for-each-language">Configuring the Installer for each Language</a></h3>
<p>A configuration object can be defined for each language to configure
localization strings:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;windows&quot;: {
        &quot;wix&quot;: {
          &quot;language&quot;: {
            &quot;en-US&quot;: null,
            &quot;pt-BR&quot;: {
              &quot;localePath&quot;: &quot;./wix/locales/pt-BR.wxl&quot;
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>The <code>localePath</code> property defines the path to a language file, a XML
configuring the language culture:</p>
<pre><code class="language-xml">&lt;WixLocalization
  Culture=&quot;en-US&quot;
  xmlns=&quot;http://schemas.microsoft.com/wix/2006/localization&quot;
&gt;
  &lt;String Id=&quot;LaunchApp&quot;&gt; Launch MyApplicationName &lt;/String&gt;
  &lt;String Id=&quot;DowngradeErrorMessage&quot;&gt;
    A newer version of MyApplicationName is already installed.
  &lt;/String&gt;
  &lt;String Id=&quot;PathEnvVarFeature&quot;&gt;
    Add the install location of the MyApplicationName executable to
    the PATH system environment variable. This allows the
    MyApplicationName executable to be called from any location.
  &lt;/String&gt;
  &lt;String Id=&quot;InstallAppFeature&quot;&gt;
    Installs MyApplicationName.
  &lt;/String&gt;
&lt;/WixLocalization&gt;
</code></pre>
<blockquote>
<p>The <code>WixLocalization</code> element's <code>Culture</code> field must match the
configured language.</p>
</blockquote>
<p>Currently Tauri references the following locale strings: <code>LaunchApp</code>,
<code>DowngradeErrorMessage</code>, <code>PathEnvVarFeature</code> and <code>InstallAppFeature</code>.
You can define your own strings and reference them on your custom
template or fragments with <code>&quot;!(loc.TheStringId)&quot;</code>. See the <a href="https://wixtoolset.org/documentation/manual/v3/howtos/ui_and_localization/make_installer_localizable.html">WiX
localization documentation</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-bundle"><a class="header" href="#macos-bundle">macOS Bundle</a></h1>
<p>Tauri applications for macOS are distributed either with an
<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html">Application Bundle</a> (<code>.app</code> files) or an Apple Disk Image (<code>.dmg</code>
files). The Tauri CLI automatically bundles your application code in
these formats, providing options to codesign and notarize your
application.</p>
<h2 id="setting-a-minimum-system-version"><a class="header" href="#setting-a-minimum-system-version">Setting a Minimum System Version</a></h2>
<p>The minimum version of the operating system required for a Tauri app
to run in macOS is <code>10.13</code>. If you need support for newer macOS APIs
like <code>window.print</code> that is only supported from macOS version <code>11.0</code>
onwards, you can change the
<a href="building//docs/api/config#tauri.bundle.macOS.minimumSystemVersion"><code>tauri.bundle.macOS.minimumSystemVersion</code></a>. This will in turn set the
<code>Info.plist</code> <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/lsminimumsystemversion">LSMinimumSystemVersion</a> property and the
<code>MACOSX_DEPLOYMENT_TARGET</code> environment variable.</p>
<blockquote>
<p>Note: macOS High Sierra (10.13) no longer receives security updates
from Apple. You should target macOS Catalina (10.15) if possible.</p>
</blockquote>
<h2 id="binary-targets"><a class="header" href="#binary-targets">Binary Targets</a></h2>
<p>macOS applications can target Apple Silicon, Intel-based Mac
computers, or universal macOS binaries that work on both
architectures. By default, the Tauri CLI uses your machine's
architecture, but you can configure a different target using the
<code>--target</code> flag:</p>
<pre><code class="language-console">tauri build --target aarch64-apple-darwin
</code></pre>
<p>Supported targets are:</p>
<ul>
<li><code>aarch64-apple-darwin</code> - Apple silicon, also known as m1 Macs, for
all models introduced <a href="https://support.apple.com/en-us/HT211814">after late 2020</a>.</li>
<li><code>x86_64-apple-darwin</code> - Intel-based Macs, all Macs introduced before
fall 2020.</li>
<li><code>universal-apple-darwin</code> - produces a <a href="https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary">Universal macOS Binary</a> that
runs on both Apple silicon and Intel-based Macs.</li>
</ul>
<p>While Apple silicon machines can run applications compiled for
Intel-based Macs through a translation layer called <a href="https://support.apple.com/en-gb/HT211861">Rosetta</a>, they
tend to suffer from performance problems. It is common practice to let
the user choose the correct target when downloading the app, but you
can also choose to distribute a <a href="https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary">Universal
Binary</a>. Universal Binaries include both
<code>aarch64</code> <strong>and</strong> <code>x86_64</code> executables, giving you the best experience
on both architectures. Note, however, that this increases your bundle
size significantly.</p>
<h2 id="application-bundle-customization"><a class="header" href="#application-bundle-customization">Application Bundle Customization</a></h2>
<p>The Tauri configuration file provides the following options to
customize your application bundle:</p>
<ul>
<li><strong>Bundle name</strong> - Your apps human-readable name. Configured by the
<a href="building//docs/api/config/#package.productName"><code>package.productName</code></a> property.</li>
<li><strong>Bundle version</strong> - Your apps version. Configured by the
<a href="building//docs/api/config/#package.version"><code>package.version</code></a> property.</li>
<li><strong>Application category</strong> - The category that describes your app.
Configured by the <a href="building//docs/api/config/#tauri.bundle.category"><code>tauri.bundle.category</code></a> property. You can see a
list of macOS categories <a href="https://developer.apple.com/app-store/categories/">here</a>.</li>
<li><strong>Copyright</strong> - A copyright string associated with your app.
Configured by the <a href="building//docs/api/config/#tauri.bundle.copyright"><code>tauri.bundle.copyright</code></a> property.</li>
<li><strong>Bundle icon</strong> - Your apps icon. Uses the first <code>.icns</code> file listed
on the <a href="building//docs/api/config/#tauri.bundle.icon"><code>tauri.bundle.icon</code></a> array.</li>
<li><strong>Minimum system version</strong> - Configured by the
<a href="building//docs/api/config#tauri.bundle.macOS.minimumSystemVersion"><code>tauri.bundle.macOS.minimumSystemVersion</code></a> property.</li>
<li><strong>DMG license file</strong> - A license that is added to the <code>.dmg</code> file.
Configure by the <a href="building//docs/api/config/#tauri.bundle.macOS.license"><code>tauri.bundle.macOS.license</code></a> property.</li>
<li><strong><a href="https://developer.apple.com/documentation/bundleresources/entitlements">Entitlements.plist file</a></strong> - Entitlements control what APIs your
app will have access to. Configured by the
<a href="building//docs/api/config/#tauri.bundle.macOS.entitlements"><code>tauri.bundle.macOS.entitlements</code></a> property.</li>
<li><strong>Exception domain</strong> - an insecure domain that your application can
access such as a <code>localhost</code> or a remote <code>http</code> domain. It is a
convenience configuration around
<code>NSAppTransportSecurity &gt; NSExceptionDomains</code> setting
<code>NSExceptionAllowsInsecureHTTPLoads</code> and <code>NSIncludesSubdomains</code> to
true. See <a href="building//docs/api/config/#tauri.bundle.macOS.exceptionDomain"><code>tauri.bundle.macOS.exceptionDomain</code></a>.</li>
<li><strong>Bootstrapper</strong> - Instead of launching the app directly, you can
configure the bundled app to run a script that tries to expose the
environment variables to the app; without that, you'll have trouble
using system programs because the <code>PATH</code> environment variable isn't
correct. Enable it with <a href="building//docs/api/config#tauri.bundle.deb.useBootstrapper"><code>tauri.bundle.macOS.useBootstrapper</code></a>.</li>
</ul>
<blockquote>
<p>These options generate the application bundle <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html">Info.plist file</a>. You
can extend the generated file with your own <code>Info.plist</code> file stored
on the Tauri folder (<code>src-tauri</code> by default). The CLI merges both
<code>.plist</code> files on production, and the core layer embeds it on the
binary on development.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updater-artifacts"><a class="header" href="#updater-artifacts">Updater Artifacts</a></h1>
<p>The Tauri bundler automatically generates update artifacts if the
updater is enabled in <code>tauri.conf.json</code> Your update artifacts are
automatically signed if the bundler can locate your private and public
key.</p>
<p>The signature can be found in the <code>sig</code> file. The signature can be
uploaded to GitHub safely or made public if your private key is
secure.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>On macOS, Tauri creates a .tar.gz from the whole application. (.app)</p>
<pre><code class="language-text">target/release/bundle
└── osx
    └── app.app
    └── app.app.tar.gz (update bundle)
    └── app.app.tar.gz.sig (if signature enabled)
</code></pre>
<h3 id="windows-3"><a class="header" href="#windows-3">Windows</a></h3>
<p>On Windows, Tauri creates a .zip from the MSI; when downloaded and
validated, we run the MSI install.</p>
<pre><code class="language-text">target/release
└── app.x64.msi
└── app.x64.msi.zip (update bundle)
└── app.x64.msi.zip.sig (if signature enabled)
</code></pre>
<h3 id="linux-2"><a class="header" href="#linux-2">Linux</a></h3>
<p>On Linux, Tauri creates a .tar.gz from the AppImage.</p>
<pre><code class="language-text">target/release/bundle
└── appimage
    └── app.AppImage
    └── app.AppImage.tar.gz (update bundle)
    └── app.AppImage.tar.gz.sig (if signature enabled)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reducing-the-app-size"><a class="header" href="#reducing-the-app-size">Reducing the App Size</a></h1>
<p>With Tauri, we are working to reduce the environmental footprint of
applications by using system resources where available, providing
compiled systems that don't need runtime evaluation, and offering
guides so that engineers can go even smaller without sacrificing
performance or security. The point is, by saving resources, we are
doing our part to help you help us save the planet -- which is the
only bottom line that companies in the 21st Century should care about.</p>
<p>So if you are interested in learning how to improve your app size and
performance, read on!</p>
<h3 id="you-cant-improve-what-you-cant-measure"><a class="header" href="#you-cant-improve-what-you-cant-measure">You can't improve what you can't measure</a></h3>
<p>Before you can optimize your app, you need to figure out what takes up
space in your app! Here are a couple of tools that can assist you with
that:</p>
<ul>
<li>
<p><strong><code>cargo-bloat</code></strong> - A rust utility to determine what takes the most
space in your app. It gives you an excellent, sorted overview of the
most significant rust functions.</p>
</li>
<li>
<p><strong><code>cargo-expand</code></strong> - <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros</a> make your rust code more concise and
easier to read, but they are also hidden size traps! Use
<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> to see what those macros generate
under the hood.</p>
</li>
<li>
<p><strong><code>rollup-plugin-visualizer</code></strong> - A tool that generates beautiful
(and insightful) graphs from your rollup bundle. Very convenient for
figuring out what JavaScript dependencies contribute to your final
bundle size the most.</p>
</li>
<li>
<p><strong><code>rollup-plugin-graph</code></strong> - You noticed a dependency included in
your final frontend bundle, but you are unsure why?
<a href="https://github.com/ondras/rollup-plugin-graph"><code>rollup-plugin-graph</code></a> generates graphviz
compatible visualizations of your entire dependency graph.</p>
</li>
</ul>
<p>These are just a couple of tools that you might use. Make sure to
check your frontend bundlers plugin list for more!</p>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<!-- prettier-ignore -->
<ul>
<li><a href="building/reducing-the-app-size.html#1-minify-javascript">1. Minify Javascript</a></li>
<li><a href="building/reducing-the-app-size.html#2-optimize-dependencies">2. Optimize Dependencies</a></li>
<li><a href="building/reducing-the-app-size.html#3-optimize-images">3. Optimize Images</a></li>
<li><a href="building/reducing-the-app-size.html#4-remove-unnecessary-custom-fonts">4. Remove Unnecessary Custom Fonts</a></li>
<li><a href="building/reducing-the-app-size.html#5-allowlist-config">5. Allowlist Config</a></li>
<li><a href="building/reducing-the-app-size.html#6-rust-build-time-optimizations">6. Rust Build-time Optimizations</a></li>
<li><a href="building/reducing-the-app-size.html#7-stripping">7. Stripping</a></li>
<li><a href="building/reducing-the-app-size.html#8-upx">8. UPX</a></li>
</ul>
<h2 id="1-minify-javascript"><a class="header" href="#1-minify-javascript">1. Minify Javascript</a></h2>
<h3 id="why-1"><a class="header" href="#why-1">Why?</a></h3>
<p>JavaScript makes up a large portion of a typical Tauri app, so it's
important to make the JavaScript as lightweight as possible.</p>
<h3 id="how-1"><a class="header" href="#how-1">How?</a></h3>
<p>You can choose among a plethora of JavaScript bundlers; popular
choices are <a href="https://vitejs.dev">Vite</a>, <a href="https://webpack.js.org">webpack</a>, and <a href="https://rollupjs.org/guide/en/">rollup</a>. All of them can produce
minified JavaScript if configured correctly, so please consult your
bundler documentation for specific options. Generally speaking;
however, you should make sure to:</p>
<ul>
<li>
<p><strong>Enable tree shaking</strong></p>
<p>This option removes unused JavaScript from your bundle. All popular
bundlers enable this by default.</p>
</li>
<li>
<p><strong>Enable minification</strong></p>
<p>Minification removes unnecessary whitespace, shortens variable
names, and applies other optimizations. Most bundlers enable this by
default; a notable exception is <a href="https://rollupjs.org/guide/en/">rollup</a>, where you need plugins
like <a href="https://github.com/TrySound/rollup-plugin-terser">rollup-plugin-terser</a> or <a href="https://github.com/TrySound/rollup-plugin-uglify">rollup-plugin-uglify</a>.</p>
<blockquote>
<p>Note: You can use minifiers like <a href="https://terser.org">terser</a> and <a href="https://esbuild.github.io">esbuild</a> as
standalone tools.</p>
</blockquote>
</li>
<li>
<p><strong>Disable source maps</strong></p>
<p>Source maps provide a pleasant developer experience when working
with languages that compile to JavaScript, such as <a href="https://www.typescriptlang.org">TypeScript</a>. As
source maps tend to be quite large, you must disable them when
building for production. They have no benefit to your end-user, so
it's effectively dead weight.</p>
</li>
</ul>
<h2 id="2-optimize-dependencies"><a class="header" href="#2-optimize-dependencies">2. Optimize Dependencies</a></h2>
<p>Many popular libraries have smaller and faster alternatives that you
can choose instead.</p>
<h3 id="why-2"><a class="header" href="#why-2">Why?</a></h3>
<p>Most libraries you use depend on many libraries themselves, so a
library that looks inconspicuous at first glance might add <strong>several
megabytes</strong> worth of code to your app.</p>
<h3 id="how-2"><a class="header" href="#how-2">How?</a></h3>
<p>You can use <a href="https://bundlephobia.com">Bundlephobia</a> to find the cost of JavaScript
dependencies. Inspecting the cost of rust dependencies is generally
harder since the compiler does many optimizations.</p>
<p>If you find a library that seems excessively large, google around,
chances are someone else already had the same thought and created an
alternative. A good example is <a href="https://momentjs.com">Moment.js</a> and it's <a href="https://github.com/you-dont-need/You-Dont-Need-Momentjs">Many
alternatives</a>.</p>
<p>But keep in mind: <strong>The best dependency is no dependency</strong>, meaning
that you should always prefer language builtins over 3rd party
packages.</p>
<h2 id="3-optimize-images"><a class="header" href="#3-optimize-images">3. Optimize Images</a></h2>
<h3 id="why-3"><a class="header" href="#why-3">Why?</a></h3>
<p>According to the <a href="https://httparchive.org">Http Archive</a>, images are the <a href="https://httparchive.org/reports/page-weight#bytesImg">biggest contributor
to website weight</a>. So if your app
includes have background images or icons, make sure to optimize them!</p>
<h3 id="how-3"><a class="header" href="#how-3">How?</a></h3>
<p>You can choose between a variety of manual options (<a href="https://www.gimp.org">GIMP</a>,
<a href="https://www.adobe.com/de/products/photoshop.html">Photoshop</a>, <a href="https://squoosh.app">Squoosh</a>) or plugins for your favorite frontend build
tools (<a href="https://github.com/JonasKruckenberg/imagetools">vite-imagetools</a>, <a href="https://github.com/vbenjs/vite-plugin-imagemin">vite-plugin-imagemin</a>,
<a href="https://github.com/webpack-contrib/image-minimizer-webpack-plugin">image-minimizer-webpack-plugin</a>).</p>
<blockquote>
<p>The <code>imagemin</code> library most of the plugins use is <a href="https://github.com/imagemin/imagemin/issues/385">officially
unmaintained</a>.</p>
</blockquote>
<ul>
<li>
<p><strong>Use modern image formats</strong></p>
<p>Formats such as <code>webp</code> or <code>avif</code> offer size reductions of <strong>up to
95%</strong> compared to jpeg while maintaining excellent visual accuracy.
You can use tools such as <a href="https://squoosh.app">Squoosh</a> to try different formats on your
images.</p>
</li>
<li>
<p><strong>Size images accordingly</strong></p>
<p>No one appreciates you shipping the 6K raw image with your app, so
make sure to size your image accordingly. Images that appear large
on-screen should be sized larger than images that take up less
screen space.</p>
</li>
<li>
<p><strong>Don't use Responsive Images</strong></p>
<p>In a Web Environment, you are supposed to use <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">Responsive Images</a> to
load the correct image size for each user dynamically. You are not
building a simple website, though: All your images are already
downloaded. So using Responsive Images only bloat your app with
redundant copies.</p>
</li>
<li>
<p><strong>Remove Metadata</strong></p>
<p>Images that were taken straight from a camera or stock photo side
often include metadata about the Camera and Lens model or
Photographer. Not only are those wasted bytes, but metadata
properties can also hold potentially sensitive information such as
the time, day, and location of the photo.</p>
</li>
</ul>
<h2 id="4-remove-unnecessary-custom-fonts"><a class="header" href="#4-remove-unnecessary-custom-fonts">4. Remove Unnecessary Custom Fonts</a></h2>
<p>Consider not shipping custom fonts with your app and relying on system
fonts instead. If you must ship custom fonts, make sure they are in
modern, optimized formats such as <code>woff2</code>.</p>
<h3 id="why-4"><a class="header" href="#why-4">Why?</a></h3>
<p>Fonts can be pretty big, so using the fonts already included in the
Operating System reduces the footprint of your app. It also avoids
FOUT (Flash of Unstyled Text) and makes your app feel more &quot;native&quot;
since it uses the same font as all other apps.</p>
<p>If you must include custom fonts, make sure you include them in modern
formats such as <code>woff2</code> as those tend to be way smaller than legacy
formats.</p>
<h3 id="how-4"><a class="header" href="#how-4">How?</a></h3>
<p>Use so-called <strong>&quot;System Font Stacks&quot;</strong> in your CSS. There are a number
of variations, but here are 3 basic ones to get you started:</p>
<ul>
<li>
<p><strong>Sans-serif</strong></p>
<pre><code class="language-css">font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;,
  Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;,
  &quot;Segoe UI Emoji&quot;;
</code></pre>
</li>
<li>
<p><strong>Serif</strong></p>
<pre><code class="language-css">font-family: Iowan Old Style, Apple Garamond, Baskerville,
  Times New Roman, Droid Serif, Times, Source Serif Pro, serif, Apple
    Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
</code></pre>
</li>
<li>
<p><strong>Monospace</strong></p>
<pre><code class="language-css">font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas,
  Liberation Mono, monospace;
</code></pre>
</li>
</ul>
<h2 id="5-allowlist-config"><a class="header" href="#5-allowlist-config">5. Allowlist Config</a></h2>
<p>You can reduce the size of your app by only enabling the Tauri API
features you need in the <code>allowlist</code> config.</p>
<h3 id="why-5"><a class="header" href="#why-5">Why?</a></h3>
<p>The <code>allowlist</code> config determines what API features to enable;
disabled features will <strong>not be compiled into your app</strong>. This is an
easy way of shedding some extra weight.</p>
<h3 id="how-5"><a class="header" href="#how-5">How?</a></h3>
<p>An example from a typical <code>tauri.conf.json</code>:</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;allowlist&quot;: {
      &quot;all&quot;: false,
      &quot;fs&quot;: {
        &quot;writeFile&quot;: true
      },
      &quot;shell&quot;: {
        &quot;execute&quot;: true
      },
      &quot;dialog&quot;: {
        &quot;save&quot;: true
      }
    }
  }
}
</code></pre>
<h2 id="6-rust-build-time-optimizations"><a class="header" href="#6-rust-build-time-optimizations">6. Rust Build-time Optimizations</a></h2>
<p>Configure your cargo project to take advantage of rusts size
optimization features. <a href="https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html">Why is a rust executable large ?</a> provides an
excellent explanation on why this matters and an in-depth walkthrough.
At the same time, <a href="https://github.com/johnthagen/min-sized-rust">Minimizing Rust Binary Size</a> is more up-to-date and
has a couple of extra recommendations.</p>
<h3 id="why-6"><a class="header" href="#why-6">Why?</a></h3>
<p>Rust is notorious for producing large binaries, but you can instruct
the compiler to optimize the final executable's size.</p>
<h3 id="how-6"><a class="header" href="#how-6">How?</a></h3>
<p>Cargo exposes several options that determine how the compiler
generates your binary. The &quot;recommended&quot; options for Tauri apps are
these:</p>
<pre><code class="language-toml">[profile.release]
panic = &quot;abort&quot; # Strip expensive panic clean-up logic
codegen-units = 1 # Compile crates one after another so the compiler can optimize better
lto = true # Enables link to optimizations
opt-level = &quot;s&quot; # Optimize for binary size
</code></pre>
<blockquote>
<p>There is also <code>opt-level = &quot;z&quot;</code> available to reduce the resulting
binary size. <code>&quot;s&quot;</code> and <code>&quot;z&quot;</code> can sometimes be smaller than the
other, so test it with your application!</p>
<p>We've seen smaller binary sizes from <code>&quot;s&quot;</code> for Tauri example
applications, but real-world applications can always differ.</p>
</blockquote>
<p>For a detailed explanation of each option and a bunch more, refer to
the <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo books Profiles section</a>.</p>
<h3 id="unstable-rust-compression-features"><a class="header" href="#unstable-rust-compression-features">Unstable Rust Compression Features</a></h3>
<blockquote>
<p>The following suggestions are all unstable features and require a
nightly toolchain. See the <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features">Unstable
Features</a> documentation for more
information on what this involves.</p>
</blockquote>
<p>The following methods involve using unstable compiler features and
require the rust nightly toolchain. If you don't have the nightly
toolchain + <code>rust-src</code> nightly component added, try the following:</p>
<pre><code class="language-bash">rustup toolchain install nightly
rustup component add rust-src --toolchain nightly
</code></pre>
<p>The Rust Standard Library comes precompiled. This means rust is faster
to install, but also that the compiler can't optimize the Standard
Library. You can apply the optimization options for the rest of your
binary + dependencies to the std with an unstable flag. This flag
requires specifying your target, so know the target triple you are
targeting.</p>
<pre><code class="language-bash">cargo +nightly build --release -Z build-std --target x86_64-unknown-linux-gnu
</code></pre>
<p>If you are using <code>panic = &quot;abort&quot;</code> in your release profile
optimizations, you need to make sure the <code>panic_abort</code> crate is
compiled with std. Additionally, an extra std feature can further
reduce the binary size. The following applies both:</p>
<pre><code class="language-bash">cargo +nightly build --release -Z build-std=std,panic_abort -Z build-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu
</code></pre>
<p>See the unstable documentation for more details about
<a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std"><code>-Z build-std</code></a> and
<a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features"><code>-Z build-std-features</code></a>.</p>
<h2 id="7-stripping"><a class="header" href="#7-stripping">7. Stripping</a></h2>
<p>Use strip utilities to remove debug symbols from your compiled app.</p>
<h3 id="why-7"><a class="header" href="#why-7">Why?</a></h3>
<p>Your compiled app includes so-called &quot;Debug Symbols&quot; that include
function and variable names. Your end-users will probably not care
about Debug Symbols, so this is a pretty surefire way to save some
bytes!</p>
<h3 id="how-7"><a class="header" href="#how-7">How?</a></h3>
<p>The easiest way is to use the famous <code>strip</code> utility to remove this
debugging information.</p>
<pre><code class="language-bash">strip target/release/my_application
</code></pre>
<p>See your local <code>strip</code> manpage for more information and flags that can
be used to specify what information gets stripped out from the binary.</p>
<blockquote>
<p>Rust 1.59 now has a builtin version of <code>strip</code>! <br> It can be
enabled by adding the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
strip = true  # Automatically strip symbols from the binary.
</code></pre>
</blockquote>
<!-- TODO: add a note that strip if builtin with rust >= 1.59 -->
<h2 id="8-upx"><a class="header" href="#8-upx">8. UPX</a></h2>
<p>UPX, <strong>Ultimate Packer for eXecutables</strong>, is a dinosaur amongst the
binary packers. This 23-year old, well-maintained piece of kit is
GPL-v2 licensed with a pretty liberal usage declaration. Our
understanding of the licensing is that you can use it for any purposes
(commercial or otherwise) without needing to change your license
unless you modify the source code of UPX.</p>
<h3 id="why-8"><a class="header" href="#why-8">Why?</a></h3>
<p>Maybe your target audience has very slow internet, or your app needs
to fit on a tiny USB stick, and all the above steps haven't resulted
in the savings you need. Fear not, as we have one last trick up our
sleeves:</p>
<p><a href="https://github.com/upx/upx">UPX</a> compresses your binary and creates a self-extracting executable
that decompresses itself at runtime.</p>
<h3 id="how-8"><a class="header" href="#how-8">How?</a></h3>
<blockquote>
<p>You should know that this technique might flag your binary as a
virus on Windows and macOS - so use at your own discretion, and as
always, validate with <a href="https://frida.re/docs/home/">Frida</a> and do real distribution testing!</p>
</blockquote>
<h4 id="usage-on-macos"><a class="header" href="#usage-on-macos">Usage on macOS</a></h4>
<pre><code class="language-bash">brew install upx
yarn tauri build
upx --ultra-brute src-tauri/target/release/bundle/macos/app.app/Contents/macOS/app

                        Ultimate Packer for eXecutables
                            Copyright (C) 1996 - 2018
UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018

        File size         Ratio      Format      Name
    --------------------   ------   -----------   -----------
    963140 -&gt;    274448   28.50%   macho/amd64   app
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-application-distribution"><a class="header" href="#windows-application-distribution">Windows Application Distribution</a></h1>
<p>This guide provides information on code signing and uploading your app
to the Windows Store.</p>
<h2 id="code-signing"><a class="header" href="#code-signing">Code Signing</a></h2>
<p>Code signing your application lets users know that they downloaded the
official executable of your app and not some malware that poses as
your app. While it is not required, it improves users' confidence in
your app.</p>
<p>The following list walks you through the necessary steps to code-sign
a Windows application.</p>
<ol start="0">
<li>
<p><strong>Prerequisites</strong></p>
<p>This guide assumes you run Windows, either on a physical machine or
a <a href="distributing/../development/vms.html">Virtual Machine</a> and that you already have a working Tauri
application.</p>
</li>
<li>
<p><strong>Get a Code Signing Certificate</strong></p>
<p>To sign your application, you need to acquire a <strong>Code Signing
certificate</strong> from one of the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate#extended-validation-code-signing-certificates">supported certificate authorities</a>
like Digicert, Sectigo (formerly Comodo), or Godaddy.</p>
<p>To eliminate all security prompts during installation, you need an
extended validation (EV) code signing certificate. These
certificates cost upwards of 400$ and require a hardware token.
Depending on your country, they might also be sold to companies
only.</p>
</li>
<li>
<p><strong>Create <code>.pfx</code> Certificate</strong></p>
<p>You need a <a href="https://en.wikipedia.org/wiki/PKCS_12">PKCS 12</a> Certificate file to sign an executable,
commonly called a PFX file. We will take the certificate file (e.g.
<code>cert.cer</code>) and private key (e.g. <code>private-key.key</code>) you received
from your certificate authority and convert them into a <code>.pfx</code>
file. <br> Open a PowerShell prompt and enter the following
command:</p>
<pre><code class="language-powershell">openssl pkcs12 -export -in cert.cer -inkey private-key.key -out certificate.pfx
</code></pre>
<p>Make sure you don't forget the export password when prompted, we
need it in the next step.</p>
</li>
<li>
<p><strong>Import Certificate</strong></p>
<p>You now need to import your newly created <code>.pfx</code> certificate into
the Windows Keystore. First, we need to store the export password
you previously created into an environment variable. The securest
option is the <code>Get-Credential</code> helper; Enter the following command
in your PowerShell prompt:</p>
<pre><code class="language-powershell">$mypwd = Get-Credential `
         -UserName 'Enter password below' `
         -Message 'Enter password below'
</code></pre>
<p>Next, you can use the <code>Import-PfxCertificate</code> command to actually
import your <code>.pfx</code> file:</p>
<pre><code class="language-powershell">Import-PfxCertificate `
         -FilePath C:\certificate.pfx `
         -CertStoreLocation Cert:\LocalMachine\My `
         -Password $mypwd.Password
</code></pre>
</li>
<li>
<p><strong>Tauri Configuration</strong></p>
<p>To configure Tauri for code signing we need to enter a few things
into our <code>tauri.conf.json</code> file:</p>
<ul>
<li>
<p><code>certificateThumbprint</code> - The SHA-1 thumbprint of your
certificate. Enter the following command and copy the values for
<code>localKeyID</code> <strong>without spaces</strong>.</p>
<pre><code class="language-powershell">openssl pkcs12 -info -in certificate.pfx
</code></pre>
<p>For this example output the <code>certificateThumbprint</code> is <br>
<code>A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0</code>.</p>
<pre><code class="language-text">Bag Attributes
    localKeyID: A1 B1 A2 B2 A3 B3 A4 B4 A5 B5 A6 B6 A7 B7 A8 B8 A9 B9 A0 B0
</code></pre>
</li>
<li>
<p><code>digestAlgorithm</code> - The SHA digest algorithm used for your
certificate. This is likely <code>sha256</code>.</p>
</li>
<li>
<p><code>timestampUrl</code> - A URL pointing to a timestamp server used to
verify the time the certificate is signed. It's best to provide
the timestamp server provided by your certificate authority here.</p>
</li>
<li>
<p><code>tsp</code> - Enables the <em>Time-Stamp Protocol</em> (TSP, defined by <a href="https://datatracker.ietf.org/doc/html/rfc3161">RFC
3161</a>) instead of NTP. Some certificate authorities, like
<a href="https://www.ssl.com/">SSL.com</a> only provide TSP servers.</p>
</li>
</ul>
<pre><code class="language-json">&quot;bundle&quot;: {
    &quot;windows&quot;: {
            &quot;certificateThumbprint&quot;: &quot;A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0&quot;,
            &quot;digestAlgorithm&quot;: &quot;sha256&quot;,
            &quot;timestampUrl&quot;: &quot;http://timestamp.comodoca.com&quot;,
            &quot;tsp&quot;: false
    }
}
</code></pre>
</li>
<li>
<p><strong>Sign your Application</strong></p>
<p>Now you can run <code>tauri build</code> and you will see the following
additional output:</p>
<pre><code class="language-text">info: signing app
info: running signtool &quot;C:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.19041.0\\x64\\signtool.exe&quot;
info: Done Adding Additional Store
Successfully signed: APPLICATION FILE PATH HERE
</code></pre>
<p>And that's it! You have successfully signed your Tauri application!</p>
</li>
</ol>
<h2 id="continous-integration"><a class="header" href="#continous-integration">Continous Integration</a></h2>
<p>As the above-described process is rather laborious, most developers
run this step as an automated part of their Continous Integration
(CI). For users of <a href="https://github.com/features/actions">GitHub Actions</a> Tauri provides the <a href="https://github.com/tauri-apps/tauri-action">Tauri Action</a>,
which simplifies the setup.</p>
<blockquote>
<p>Note: The following example assumes you store the secret passwords
and tokens using <a href="https://docs.github.com/en/actions/reference/encrypted-secrets">GitHub Secrets</a>.</p>
</blockquote>
<figure>
<p>Filename: .github/workflows/publish.yml</p>
<pre><code class="language-yaml">name: &quot;publish&quot;
on:
  push:
    branches:
      - release

jobs:
  publish-tauri:
    strategy:
      fail-fast: false
      matrix:
        platform: [windows-latest]

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: setup node
        uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: install Rust stable
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: import windows certificate
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD:
            ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          New-Item -ItemType directory -Path certificate
          Set-Content -Path certificate/tempCert.txt -Value $env:WINDOWS_CERTIFICATE
          certutil -decode certificate/tempCert.txt certificate/certificate.pfx
          Remove-Item -path certificate -include tempCert.txt
          Import-PfxCertificate `
              -FilePath certificate/certificate.pfx `
              -CertStoreLocation Cert:\LocalMachine\My `
              -Password (ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -Force -AsPlainText)
      - name: install app dependencies
        run: yarn
      - uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: app-v__VERSION__ # the action automatically replaces \_\_VERSION\_\_ with the app version
          releaseName: &quot;App v__VERSION__&quot;
          releaseBody:
            &quot;See the assets to download this version and install.&quot;
          releaseDraft: true
          prerelease: false
</code></pre>
<figcaption>Listing 4-TODO: A GitHub Action workflow that builds, signs and publishes a Tauri application.</figcaption>
</figure>
<h2 id="submit-apps-to-the-windows-store"><a class="header" href="#submit-apps-to-the-windows-store">Submit Apps to the Windows Store</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-application-distribution"><a class="header" href="#macos-application-distribution">macOS Application Distribution</a></h1>
<p>This guide provides information on code signing, notarizing and
uploading your app to the Mac App Store.</p>
<blockquote>
<p>If you are not utilizing GitHub Actions to perform builds of OSX
DMGs, you will need to ensure the environment variable <code>CI</code> is set
to <code>true</code>. <br> For more information refer to
<a href="https://github.com/tauri-apps/tauri/issues/592">tauri-apps/tauri#592</a>.</p>
</blockquote>
<h2 id="code-signing-1"><a class="header" href="#code-signing-1">Code Signing</a></h2>
<p>On macOS Catalina and later <a href="https://support.apple.com/en-us/HT202491">Gatekeeper</a> enforces that you must sign
and notarize your application. Unsigned software cannot be run, so
contrary to <a href="distributing/windows.html#code-signing">Windows Code Signing</a> this is not optional for macOS.</p>
<ol start="0">
<li>
<p><strong>Prerequisites</strong></p>
<p>This guide assumes you run Windows, either on a physical machine or
a <a href="distributing/../development/vms.html">Virtual Machine</a>, and that you already have a working Tauri
application. You also need Xcode 11 or newer and an Apple Developer
account enrolled in the <a href="https://developer.apple.com/programs/">Apple Developer Program</a>.</p>
</li>
<li>
<p><strong>Get a Code Signing Certificate</strong></p>
<p>To create a new signing certificate, you must generate a
Certificate Signing Request (CSR) file on your Mac computer.
<a href="https://help.apple.com/developer-account/#/devbfa00fef7">Create a certificate signing request</a> describes guides you through
creating a CSR.</p>
<p>Next, open the <a href="https://developer.apple.com/account/resources/certificates/list">Certificates, IDs &amp; Profiles page</a> and click on the
<code>Add</code> button to open the interface to create a new certificate.
Choose the appropriate certificate type (<code>Apple Distribution</code> to
submit apps to the App Store, and <code>Developer ID Application</code> to
ship apps outside the App Store). Upload your CSR, and the
certificate will be created.</p>
<blockquote>
<p>Only the Apple Developer <em>Account Holder</em> can create
<code>Developer ID Application</code> certificates. But it can be associated
with a different Apple ID by creating a CSR with a different user
email address.</p>
</blockquote>
</li>
<li>
<p><strong>Downloading the Certificate</strong></p>
<p>On <a href="https://developer.apple.com/account/resources/certificates/list">Certificates, IDs &amp; Profiles page</a>, click on the certificate
you want to use and click the <code>Download</code> button. It saves a <code>.cer</code>
file that installs the certificate on the keychain once opened. The
name of the keychain entry represents the <em>signing identity</em>, which
can also be found by running this command:
<code>security find-identity -v -p codesigning</code>.</p>
<blockquote>
<p>A signing certificate is only valid if associated with your Apple
ID. An invalid certificate won't be listed on the
<code>Keychain Access &gt; My Certificates</code> tab or the
<code>security find-identity -v -p codesigning</code> output.</p>
</blockquote>
</li>
<li>
<p><strong>Tauri Configuration</strong></p>
<p>To have the Tauri bundler sign your application, you need to
configure it. This is done by setting a number of environment
variables.</p>
<h4 id="certificate-environment-variables"><a class="header" href="#certificate-environment-variables">Certificate environment variables</a></h4>
<ul>
<li><code>APPLE_SIGNING_IDENTITY</code> - this is the <em>signing identity</em> we
highlighted earlier. It must be defined to sign apps both locally
and on CI machines.</li>
</ul>
<p>Additionally, to simplify the code signing process on CI, Tauri can
automatically install the certificate on the keychain if you define
the <code>APPLE_CERTIFICATE</code> and <br> <code>APPLE_CERTIFICATE_PASSWORD</code>
environment variables.</p>
<ol>
<li>Open the <code>Keychain Access</code> app and find your certificate's
keychain entry.</li>
<li>Expand the entry, double click on the key item, and select
<code>Export &quot;$KEYNAME&quot;</code>.</li>
<li>Select the path to save the <code>.p12</code> file and define the exported
certificate password.</li>
<li>Convert the <code>.p12</code> file to base64 running the following script
on the terminal: `
<pre><code class="language-console">openssl base64 -in /path/to/certificate.p12 -out certificate-base64.txt
</code></pre>
</li>
<li>Set the contents of the <code>certificate-base64.txt</code> file to the
<code>APPLE_CERTIFICATE</code> environment variable.</li>
<li>Set the certificate password to the <code>APPLE_CERTIFICATE_PASSWORD</code>
environment variable.</li>
</ol>
<h4 id="authentication-environment-variables"><a class="header" href="#authentication-environment-variables">Authentication environment variables</a></h4>
<ul>
<li>
<p><code>APPLE_ID</code> and <code>APPLE_PASSWORD</code> - to authenticate with your Apple
ID, set the <code>APPLE_ID</code> to your Apple account email (example:
<code>export APPLE_ID=tauri@icloud.com</code>) and the <code>APPLE_PASSWORD</code> to
an <a href="https://support.apple.com/en-ca/HT204397">app-specific password</a> for the Apple account.</p>
</li>
<li>
<p><code>APPLE_API_ISSUER</code> and <code>APPLE_API_KEY</code> - alternatively, you can
authenticate using an App Store Connect API key. <br> Open the
App Store Connect's <a href="https://appstoreconnect.apple.com/access/users">Users and Access page</a>, click the <code>Add</code>
button and select a name and check <code>Developer Access</code>. The
<code>APPLE_API_ISSUER</code> (Issuer ID) is presented above the keys table,
and the <code>APPLE_API_KEY</code> is the value of the <code>Key ID</code> column of
that table. You also need to download the private key, which can
only be done once and is only visible after a page reload (the
button is shown on the table row for the newly created key). The
private key file must be saved in one of these location
<code>./private_keys</code>, <code>~/private_keys</code>, <code>~/.private_keys</code> or
<code>~/.appstoreconnect/private_keys</code>, as stated by
<code>xcrun altool --help</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Sign your Application</strong></p>
<p>Now the Tauri bundler will sign and notarize your application
automatically whenever you run <code>tauri build</code>.</p>
<p>Congratulations! You have successfully signed your Tauri
application!</p>
</li>
</ol>
<h2 id="continous-integration-1"><a class="header" href="#continous-integration-1">Continous Integration</a></h2>
<p>As the above-described process is rather laborious, most developers
run this step as an automated part of their Continous Integration
(CI). For users of <a href="https://github.com/features/actions">GitHub Actions</a> Tauri provides the <a href="https://github.com/tauri-apps/tauri-action">Tauri Action</a>,
which simplifies the setup.</p>
<blockquote>
<p>Note: The following example assumes you store the secret passwords
and tokens using <a href="https://docs.github.com/en/actions/reference/encrypted-secrets">GitHub Secrets</a>.</p>
</blockquote>
<figure>
<p>Filename: .github/workflows/publish.yml</p>
<pre><code class="language-yaml">name: &quot;publish&quot;
on:
  push:
    branches:
      - release

jobs:
  publish-tauri:
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest]

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 12
      - name: install Rust stable
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: install app dependencies
        run: yarn
      - uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ENABLE_CODE_SIGNING: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD:
            ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY:
            ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
        with:
          tagName: app-v__VERSION__ # the action automatically replaces \_\_VERSION\_\_ with the app version
          releaseName: &quot;App v__VERSION__&quot;
          releaseBody:
            &quot;See the assets to download this version and install.&quot;
          releaseDraft: true
          prerelease: false
</code></pre>
<figcaption>Listing 4-TODO: A GitHub Action workflow that builds, signs, notarizes and publishes a Tauri application.</figcaption>
</figure>
<h2 id="submit-apps-to-the-mac-app-store"><a class="header" href="#submit-apps-to-the-mac-app-store">Submit Apps to the Mac App Store</a></h2>
<p>After signing your application, you can now submit it to the Mac App
Store. You should make sure your app adheres to <a href="https://help.apple.com/xcode/mac/current/#/dev067853c94">Apple's
requirements</a>.</p>
<h3 id="macos-private-apis"><a class="header" href="#macos-private-apis">macOS Private APIs</a></h3>
<p>If you have <a href="https://tauri.studio/docs/api/config#tauri.macOSPrivateApi"><code>tauri.macOSPrivateApi</code></a> enabled and make use of features
like the transparent background or developer tools in production
builds, your app can't be submitted to the Mac App Store.</p>
<h3 id="entitlements"><a class="header" href="#entitlements">Entitlements</a></h3>
<p>Depending on the features you have enabled, you may need to request
additional permissions by creating an <a href="https://developer.apple.com/documentation/bundleresources/entitlements"><code>entitlements.plist</code></a> file. Use
the <a href="distributing//docs/api/config/#tauri.bundle.macOS.entitlements"><code>tauri.bundle.macos.entitlements</code></a> property to include the file
in your final bundle.</p>
<h4 id="network-access"><a class="header" href="#network-access">Network access</a></h4>
<p>Enable outgoing network connections to allow your app to connect to a
server:</p>
<pre><code class="language-xml">&lt;key&gt;com.apple.security.network.client&lt;/key&gt;
&lt;true/&gt;
</code></pre>
<p>Enable incoming network connections to allow your app to open a
network listening socket:</p>
<pre><code class="language-xml">&lt;key&gt;com.apple.security.network.server&lt;/key&gt;
&lt;true/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updater"><a class="header" href="#updater">Updater</a></h1>
<p>The updater is focused on making Tauri's application updates <strong>as safe
and transparent as updates to a website</strong>.</p>
<p>Instead of publishing a feed of versions from which your app must
select, Tauri updates to the version your server tells it to. This
allows you to intelligently update your clients based on the request
you give to Tauri. The server can remotely drive behaviors like
rolling back or phased rollouts. The update JSON Tauri requests should
be dynamically generated based on criteria in the request and whether
an update is required. Tauri's installer is also designed to be
fault-tolerant, and ensure that any updates installed are valid and
safe.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>To enable updates you must add the following to your <code>tauri.conf.json</code>
file:</p>
<pre><code class="language-json">&quot;updater&quot;: {
    &quot;active&quot;: true,
    &quot;endpoints&quot;: [
        &quot;https://releases.myapp.com/{{target}}/{{arch}}/{{current_version}}&quot;
    ],
    &quot;dialog&quot;: true,
    &quot;pubkey&quot;: &quot;YOUR_UPDATER_SIGNATURE_PUBKEY_HERE&quot;
}
</code></pre>
<p>The required keys are <code>active</code>, <code>endpoints</code> and <code>pubkey</code>; others are
optional. <code>active</code> must be a boolean. By default, it's set to false.
<code>endpoints</code> must be an array. The strings <code>{{current_version}}</code> and
<code>{{target}}</code> and <code>{{arch}}</code> are automatically replaced in the URL,
allowing you to determine <a href="distributing/updater.html#dynamic-json-format">server-side</a> if an
update is available. If multiple endpoints are specified, the updater
will fall back if a server is not responding within the pre-defined
timeout. <code>dialog</code> must be a boolean if present. By default, it is set
to true. If enabled, events are turned off as the updater handles
everything. If you need the custom events, you MUST turn off the
built-in dialog. <code>pubkey</code> must be a valid public-key generated with
Tauri CLI. See <a href="distributing/updater.html#signing-updates">Signing updates</a> for details.</p>
<h2 id="update-requests"><a class="header" href="#update-requests">Update Requests</a></h2>
<p>The Tauri updater will periodically send an HTTP GET request to the
previously configured endpoints. The return type must be
<code>application/json</code> and adhere to one of the following schemas.</p>
<h3 id="dynamic-json-format"><a class="header" href="#dynamic-json-format">Dynamic JSON Format</a></h3>
<p>The dynamic response format allows you fine grained control over the
update process. If the update server determines - based on the update
request - that an update is necessary, it must respond with a status
code of <a href="http://tools.ietf.org/html/rfc2616#section-10.2.1">200 OK</a> and include valid update information of the following
shape:</p>
<pre><code class="language-json">{
  &quot;url&quot;: &quot;https://mycompany.example.com/myapp/releases/myrelease.tar.gz&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;notes&quot;: &quot;Theses are some release notes&quot;,
  &quot;pub_date&quot;: &quot;2020-09-18T12:29:53+01:00&quot;,
  &quot;signature&quot;: &quot;&quot;
}
</code></pre>
<p>The only required keys are <code>url</code> and <code>version</code>; all others are
optional. <code>pub_date</code>must be formated according to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> if
present and <code>signature</code> must be a valid signature generated with the
Tauri Cli.</p>
<p>If no update is required your server must respond with a status code
of <a href="http://tools.ietf.org/html/rfc2616#section-10.2.5">204 No Content</a>.</p>
<h3 id="static-json-format"><a class="header" href="#static-json-format">Static JSON Format</a></h3>
<p>To simplify the usage with static file hosting solutions, like AWS S3,
Tauri supports an alternative static JSON response format. Tauri
checks against the <code>version</code> field, and if the version is smaller than
the current one and the platform is available, it triggers an update.
The format of this file is detailed below:</p>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;v1.0.0&quot;,
  &quot;notes&quot;: &quot;Test version&quot;,
  &quot;pub_date&quot;: &quot;2020-06-22T19:25:57Z&quot;,
  &quot;platforms&quot;: {
    &quot;darwin-aarch64&quot;: {
      &quot;signature&quot;: &quot;&quot;,
      &quot;url&quot;: &quot;https://github.com/tauri-apps/tauri-test/releases/download/v1.0.0/app-aarch64.app.tar.gz&quot;
    },
    &quot;darwin-x86_64&quot;: {
      &quot;signature&quot;: &quot;&quot;,
      &quot;url&quot;: &quot;https://github.com/tauri-apps/tauri-test/releases/download/v1.0.0/app-x86_64.app.tar.gz&quot;
    },
    &quot;linux-x86_64&quot;: {
      &quot;signature&quot;: &quot;&quot;,
      &quot;url&quot;: &quot;https://github.com/tauri-apps/tauri-test/releases/download/v1.0.0/app.AppImage.tar.gz&quot;
    },
    &quot;windows-x86_64&quot;: {
      &quot;signature&quot;: &quot;&quot;,
      &quot;url&quot;: &quot;https://github.com/tauri-apps/tauri-test/releases/download/v1.0.0/app.x64.msi.zip&quot;
    },
    &quot;windows-i686&quot;: {
      &quot;signature&quot;: &quot;&quot;,
      &quot;url&quot;: &quot;https://github.com/tauri-apps/tauri-test/releases/download/v1.0.0/app.x86.msi.zip&quot;
    }
  }
}
</code></pre>
<p>The only required keys are <code>version</code> and <code>platforms.&lt;platform&gt;.url</code>;
All others are optional. <code>pub_date</code>must be formated according to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO
8601</a> if present and <br> <code>platforms.&lt;platform&gt;.signature</code> must be a
valid signature generated with the Tauri CLI.</p>
<h2 id="built-in-update-dialog"><a class="header" href="#built-in-update-dialog">Built-in Update Dialog</a></h2>
<p>By default, the updater uses a built-in dialog API from Tauri.</p>
<p><img src="https://i.imgur.com/UMilB5A.png" alt="New Update available" /></p>
<p>The dialog release notes are filled with the <code>note</code> property of the
update response. If the user accepts, the update is downloaded and
installed. Afterward, the user is prompted to restart the application.</p>
<h2 id="programmatic-api"><a class="header" href="#programmatic-api">Programmatic API</a></h2>
<p>If you want to customize the dialog or customize the update experience
in general, you may use the <a href="distributing//docs/api/js/modules/updater"><code>@tauri-apps/api/updater</code></a> module to do
so.</p>
<blockquote>
<p>You need to disable built-in dialog. Otherwise, the javascript API
will NOT work.</p>
</blockquote>
<pre><code class="language-javascript">import { checkUpdate, installUpdate } from &quot;@tauri-apps/api/updater&quot;;
import { relaunch } from &quot;@tauri-apps/api/process&quot;;

try {
  const { shouldUpdate, manifest } = await checkUpdate();
  if (shouldUpdate) {
    // display dialog
    await installUpdate();
    // install complete, restart app
    await relaunch();
  }
} catch (error) {
  console.log(error);
}
</code></pre>
<p>The updater also emits a number of lifecycle events you may subscribe
to:</p>
<h4 id="tauriupdate-available"><a class="header" href="#tauriupdate-available"><code>tauri://update-available</code></a></h4>
<p>Emitted when a new update is available, the event includes the
following metadata:</p>
<pre><code class="language-text">version    Version announced by the server
date       Date announced by the server
body       Note announced by the server
</code></pre>
<figure>
<pre><code class="language-rust ignore">window.listen(&quot;tauri://update-available&quot;.to_string(), move |msg| {
    println!(&quot;New version available: {:?}&quot;, msg);
});
</code></pre>
<pre><code class="language-javascript">import { listen } from &quot;@tauri-apps/api/event&quot;;

listen(&quot;tauri://update-available&quot;, function (res) {
  console.log(&quot;New version available: &quot;, res);
});
</code></pre>
<figcaption>Listing 4-TODO: Listening to new update events from Rust and JavaScript.</figcaption>
</figure>
<h4 id="tauriupdate-status"><a class="header" href="#tauriupdate-status"><code>tauri://update-status</code></a></h4>
<p>Emitted while the update is downloaded and installed, you may use this
to display a progress bar.</p>
<pre><code class="language-text">status    [ERROR/PENDING/DONE]
error     String/null
</code></pre>
<p><code>PENDING</code> is emitted when the download is started and <code>DONE</code> when the
install is complete. You can then ask to restart the application.
<code>ERROR</code> is emitted when there is an error with the updater. We suggest
listening to this event even if the dialog is enabled.</p>
<figure>
<pre><code class="language-rust ignore">window.listen(&quot;tauri://update-status&quot;.to_string(), move |msg| {
    println!(&quot;New status: {:?}&quot;, msg);
});
</code></pre>
<pre><code class="language-javascript">import { listen } from &quot;@tauri-apps/api/event&quot;;

listen(&quot;tauri://update-status&quot;, function (res) {
  console.log(&quot;New status: &quot;, res);
});
</code></pre>
<figcaption>Listing 4-TODO: Listening to update progress events from Rust and JavaScript.</figcaption>
</figure>
<h2 id="signing-updates"><a class="header" href="#signing-updates">Signing Updates</a></h2>
<p>The updater offers built-in signature checking to ensure your update
is authentic and can be safely installed. When present, the update
response's <code>signature</code> field and the downloaded artifact will be
checked against the configured <code>pubkey</code> using <a href="https://jedisct1.github.io/minisign/">Minisign</a>, a simple
signature system using <a href="https://ed25519.cr.yp.to/">Ed25519</a> public-key signatures.</p>
<ol>
<li>
<p><strong>Prerequisites</strong></p>
<p>This guide assumes you have the Tauri CLI and a working Tauri
application.</p>
</li>
<li>
<p><strong>Generate Keypair</strong></p>
<p>To successfully sign and verify updates you need a <em>Keypair</em>,
consisting of</p>
<ul>
<li><strong>A Public-Key</strong> (<code>pubkey</code>) - Used to verify the signatures. This
key is safe to share with others and should be added to your
<code>tauri.conf.json</code>.</li>
<li><strong>A Private key</strong> (<code>privkey</code>) - Used to sign your update and
should <strong>NEVER</strong> be shared with anyone. If you lose this key,
you'll NOT be able to publish a new update to the current user
base. It is crucial to store it in a safe place where you can
always access it.</li>
</ul>
<p>To generate your keypair using the Tauri CLI, open a terminal and
enter the following command:</p>
<pre><code class="language-console">tauri signer generate -w ~/.tauri/myapp.key
</code></pre>
</li>
<li>
<p><strong>Tauri Configuration</strong></p>
<p>The Tauri bundler will automatically sign update artifacts if the
<code>TAURI_PRIVATE_KEY</code> and <code>TAURI_KEY_PASSWORD</code> environment variables
are set. <code>TAURI_PRIVATE_KEY</code> must be the string representation of
your private key or a path pointing to your private key file.
<code>TAURI_KEY_PASSWORD</code> must contain the private key's password if you
configured one.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-customization"><a class="header" href="#window-customization">Window Customization</a></h1>
<p>Tauri provides lots of options for customizing the look and feel of
your app's window. You can create custom titlebars, have transparent
windows, enforce size constraints, and more. This guide contains a
number of quick examples for common cases.</p>
<h2 id="creating-a-custom-titlebar"><a class="header" href="#creating-a-custom-titlebar">Creating a Custom Titlebar</a></h2>
<figure>
<picture>
  <source srcset="../img/custom_titlebar_light.avif" type="image/avif" media="(prefers-color-scheme:light)">
  <source srcset="../img/custom_titlebar_dark.avif" type="image/avif" media="(prefers-color-scheme:dark)">
  <source srcset="../img/custom_titlebar_light.webp" type="image/webp" media="(prefers-color-scheme:light)">
  <source srcset="../img/custom_titlebar_dark.webp" type="image/webp" media="(prefers-color-scheme:dark)">
  <source srcset="../img/custom_titlebar_light.png" type="image/png" media="(prefers-color-scheme:light)">
  <source srcset="../img/custom_titlebar_dark.png" type="image/png" media="(prefers-color-scheme:dark)">
  <img src="examples/../img/custom_titlebar_light.png" alt="Apple Console App"> 
</picture>
<figcaption></figcaption>
</figure>
<p>To make the custom titlebar work, you need to disable decorations for
the window by setting <a href="https://tauri.studio/docs/api/config/#tauri.windows.decorations"><code>tauri.windows.decorations</code></a>,
<a href="https://tauri.studio/docs/api/js/classes/window.WebviewWindow#setdecorations"><code>WebviewWindow.setDecorations</code></a> or <a href="https://docs.rs/tauri/1.0.0-rc.4/tauri/window/struct.WindowBuilder.html#method.decorations"><code>WindowBuilder::decorations</code></a> to
false. Next, you need to add the HTML for the titlebar. Put this at
the top of your <code>&lt;body&gt;</code> tag. Notice the <code>data-tauri-drag-region</code> data
attribute, it allows you to drag the window around like a native
titlebar would.</p>
<pre><code class="language-html">&lt;div data-tauri-drag-region class=&quot;titlebar&quot;&gt;
  &lt;div class=&quot;titlebar-button&quot; id=&quot;titlebar-minimize&quot;&gt;
    &lt;img
      src=&quot;https://api.iconify.design/mdi:window-minimize.svg&quot;
      alt=&quot;minimize&quot;
    /&gt;
  &lt;/div&gt;
  &lt;div class=&quot;titlebar-button&quot; id=&quot;titlebar-maximize&quot;&gt;
    &lt;img
      src=&quot;https://api.iconify.design/mdi:window-maximize.svg&quot;
      alt=&quot;maximize&quot;
    /&gt;
  &lt;/div&gt;
  &lt;div class=&quot;titlebar-button&quot; id=&quot;titlebar-close&quot;&gt;
    &lt;img src=&quot;https://api.iconify.design/mdi:close.svg&quot; alt=&quot;close&quot; /&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Now you need to add some CSS for the titlebar to keep it at the top of
the screen and style the buttons. Note that you may need to move the
rest of your content down so that the titlebar doesn't cover it.</p>
<pre><code class="language-css">.titlebar {
  height: 30px;
  background: #329ea3;
  user-select: none;
  display: flex;
  justify-content: flex-end;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}
.titlebar-button {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 30px;
  height: 30px;
}
.titlebar-button:hover {
  background: #5bbec3;
}
</code></pre>
<p>Finally, you need some JavaScript to make the buttons work:</p>
<pre><code class="language-javascript">import { appWindow } from &quot;@tauri-apps/api/window&quot;;
document
  .getElementById(&quot;titlebar-minimize&quot;)
  .addEventListener(&quot;click&quot;, () =&gt; appWindow.minimize());
document
  .getElementById(&quot;titlebar-maximize&quot;)
  .addEventListener(&quot;click&quot;, () =&gt; appWindow.toggleMaximize());
document
  .getElementById(&quot;titlebar-close&quot;)
  .addEventListener(&quot;click&quot;, () =&gt; appWindow.close());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-application-menu"><a class="header" href="#native-application-menu">Native Application Menu</a></h1>
<p>Native application menus can be attached to individual windows or the
whole application. Note that window-specific menus are only supported
on Windows and Linux, but not on macOS.</p>
<h2 id="creating-a-menu"><a class="header" href="#creating-a-menu">Creating a Menu</a></h2>
<p>To create a native window menu, import the <code>Menu</code>, <code>Submenu</code>,
<code>MenuItem</code> and <code>CustomMenuItem</code> types. The <code>MenuItem</code> enum contains a
collection of platform-specific items (currently not implemented on
Windows). The <code>CustomMenuItem</code> allows you to create your own menu
items and add special functionality to them.</p>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, Menu, MenuItem, Submenu};
</code></pre>
<p>Create a <code>Menu</code> instance:</p>
<pre><code class="language-rust ignore">// here `&quot;quit&quot;.to_string()` defines the menu item id,
// and the second parameter is the menu item label.
let quit = CustomMenuItem::new(&quot;quit&quot;.to_string(), &quot;Quit&quot;);
let close = CustomMenuItem::new(&quot;close&quot;.to_string(), &quot;Close&quot;);
let submenu = Submenu::new(&quot;File&quot;, Menu::new().add_item(quit).add_item(close));
let menu = Menu::new()
    .add_native_item(MenuItem::Copy)
    .add_item(CustomMenuItem::new(&quot;hide&quot;, &quot;Hide&quot;))
    .add_submenu(submenu);
</code></pre>
<h2 id="adding-the-menu-to-all-windows"><a class="header" href="#adding-the-menu-to-all-windows">Adding the Menu to all Windows</a></h2>
<p>The defined menu can be set to all windows using the <code>menu</code> method of
the <code>tauri::Builder</code> struct:</p>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, Menu, MenuItem, Submenu};

fn main() {
  let menu = Menu::new(); // configure the menu
  tauri::Builder::default()
    .menu(menu)
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="adding-the-menu-to-a-specific-window"><a class="header" href="#adding-the-menu-to-a-specific-window">Adding the Menu to a Specific Window</a></h2>
<p>You can create a window and set the menu to be used. This allows
defining a specific menu set for each application window.</p>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, Menu, MenuItem, Submenu};
use tauri::WindowBuilder;

fn main() {
  let menu = Menu::new(); // configure the menu
  tauri::Builder::default()
    .create_window(
      &quot;main-window&quot;.to_string(),
      tauri::WindowUrl::App(&quot;index.html&quot;.into()),
      move |window_builder, webview_attributes| {
        (window_builder.menu(menu), webview_attributes)
      },
    )
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="listening-to-events-on-custom-menu-items"><a class="header" href="#listening-to-events-on-custom-menu-items">Listening to Events on Custom Menu Items</a></h2>
<p>Each <code>CustomMenuItem</code> triggers an event when clicked. Use the
<code>on_menu_event</code> callback to handle them, either on the global
<code>tauri::Builder</code> or on an specific window.</p>
<h3 id="listening-to-events-on-global-menus"><a class="header" href="#listening-to-events-on-global-menus">Listening to Events on Global Menus</a></h3>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, Menu, MenuItem};

fn main() {
  let menu = vec![]; // insert the menu array here
  tauri::Builder::default()
    .menu(menu)
    .on_menu_event(|event| {
      match event.menu_item_id() {
        &quot;quit&quot; =&gt; {
          std::process::exit(0);
        }
        &quot;close&quot; =&gt; {
          event.window().close().unwrap();
        }
        _ =&gt; {}
      }
    })
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h3 id="listening-to-events-on-window-menus"><a class="header" href="#listening-to-events-on-window-menus">Listening to Events on Window Menus</a></h3>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, Menu, MenuItem};
use tauri::{Manager, WindowBuilder};

fn main() {
  let menu = vec![]; // insert the menu array here
  tauri::Builder::default()
    .create_window(
      &quot;main-window&quot;.to_string(),
      tauri::WindowUrl::App(&quot;index.html&quot;.into()),
      move |window_builder, webview_attributes| {
        (window_builder.menu(menu), webview_attributes)
      },
    )
    .setup(|app| {
      let window = app.get_window(&quot;main-window&quot;).unwrap();
      let window_ = window.clone();
      window.on_menu_event(move |event| {
        match event.menu_item_id() {
          &quot;quit&quot; =&gt; {
            std::process::exit(0);
          }
          &quot;close&quot; =&gt; {
            window_.close().unwrap();
          }
          _ =&gt; {}
        }
      });
      Ok(())
    })
    .run(tauri::generate_context!())
    .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="updating-menu-items"><a class="header" href="#updating-menu-items">Updating Menu Items</a></h2>
<p>The <code>Window</code> struct has a <code>menu_handle</code> method, which allows updating
menu items:</p>
<pre><code class="language-rust ignore">fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let main_window = app.get_window(&quot;main&quot;).unwrap();
      let menu_handle = main_window.menu_handle();
      std::thread::spawn(move || {
        // you can also `set_selected`, `set_enabled` and `set_native_image` (macOS only).
        menu_handle.get_item(&quot;item_id&quot;).set_title(&quot;New title&quot;);
      })
      Ok(())
    })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-tray"><a class="header" href="#system-tray">System Tray</a></h1>
<p>This guide walks you through adding a tray icon to the systems'
notification area. Tray icons have their own context menu.</p>
<p>On macOS and Ubuntu, the Tray will be located on the top right corner
of your screen, adjacent to your battery and wifi icons. On Windows,
the Tray will usually be located in the bottom right corner.</p>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>Add the following to your <code>tauri.conf.json</code> files <code>tauri</code> object:</p>
<pre><code class="language-diff">  &quot;tauri&quot;: {
+    &quot;systemTray&quot;: {
+      &quot;iconPath&quot;: &quot;icons/icon.png&quot;,
+      &quot;iconAsTemplate&quot;: true
+    }
  }
</code></pre>
<p><code>iconPath</code> must point to a PNG file on macOS and Linux, and a .ico
file must exist for Windows support. <code>iconAsTemplate</code> is a boolean
value that determines whether the image represents a Template Image on
macOS.</p>
<h2 id="creating-a-system-tray"><a class="header" href="#creating-a-system-tray">Creating a System Tray</a></h2>
<p>To create a native system tray, import the <code>SystemTray</code> type:</p>
<pre><code class="language-rust ignore">use tauri::SystemTray;
</code></pre>
<p>and instantiate a new tray:</p>
<pre><code class="language-rust ignore">let tray = SystemTray::new();
</code></pre>
<h2 id="configuring-a-system-tray-context-menu"><a class="header" href="#configuring-a-system-tray-context-menu">Configuring a System Tray Context Menu</a></h2>
<p>Optionally you can add a context menu that is visible when the tray
icon is clicked. Import the <code>SystemTrayMenu</code>, <code>SystemTrayMenuItem</code> and
<code>CustomMenuItem</code> types:</p>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, SystemTrayMenu, SystemTrayMenuItem};
</code></pre>
<p>Create the <code>SystemTrayMenu</code>:</p>
<pre><code class="language-rust ignore">// here `&quot;quit&quot;.to_string()` defines the menu item id,
// and the second parameter is the menu item label.
let quit = CustomMenuItem::new(&quot;quit&quot;.to_string(), &quot;Quit&quot;);
let hide = CustomMenuItem::new(&quot;hide&quot;.to_string(), &quot;Hide&quot;);

let tray_menu = SystemTrayMenu::new()
    .add_item(quit)
    .add_native_item(SystemTrayMenuItem::Separator)
    .add_item(hide);
</code></pre>
<p>Add the tray menu to the SystemTray instance:</p>
<pre><code class="language-rust ignore">let tray = SystemTray::new().with_menu(tray_menu);
</code></pre>
<h2 id="configure-the-app-system-tray"><a class="header" href="#configure-the-app-system-tray">Configure the App System Tray</a></h2>
<p>The created SystemTray instance can be set using the system_tray API
on the tauri::Builder struct:</p>
<pre><code class="language-rust ignore">use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};

fn main() {
    let tray_menu = SystemTrayMenu::new(); // insert the menu items here
    let system_tray = SystemTray::new().with_menu(tray_menu);
    tauri::Builder::default()
        .system_tray(system_tray)
        .run(tauri::generate_context!())
        .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="listening-to-system-tray-events"><a class="header" href="#listening-to-system-tray-events">Listening to System Tray Events</a></h2>
<p>Each CustomMenuItem triggers an event when clicked. Also, Tauri emits
tray icon click events. Use the <code>on_system_tray_event</code> callback to
handle them:</p>
<pre><code class="language-rust ignore">use tauri::Manager;
use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};

fn main() {
    let tray_menu = SystemTrayMenu::new(); // insert the menu items here
    tauri::Builder::default()
        .system_tray(SystemTray::new().with_menu(tray_menu))
        .on_system_tray_event(|app, event| match event {
            SystemTrayEvent::LeftClick {
                position: _,
                size: _,
                ..
            } =&gt; {
                println!(&quot;system tray received a left click&quot;);
            }
            SystemTrayEvent::RightClick {
                position: _,
                size: _,
                ..
            } =&gt; {
                println!(&quot;system tray received a right click&quot;);
            }
            SystemTrayEvent::DoubleClick {
                position: _,
                size: _,
                ..
            } =&gt; {
                println!(&quot;system tray received a double click&quot;);
            }
            SystemTrayEvent::MenuItemClick { id, .. } =&gt; match id.as_str() {
                &quot;quit&quot; =&gt; {
                    std::process::exit(0);
                }
                &quot;hide&quot; =&gt; {
                    let window = app.get_window(&quot;main&quot;).unwrap();
                    window.hide().unwrap();
                }
                _ =&gt; {}
            },
            _ =&gt; {}
        })
        .run(tauri::generate_context!())
        .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="updating-the-system-tray"><a class="header" href="#updating-the-system-tray">Updating the System Tray</a></h2>
<p>The <code>AppHandle</code> struct has a <code>tray_handle</code> method, which returns a
handle to the system tray, allowing updating tray icon and context
menu items: Updating context menu items</p>
<pre><code class="language-rust ignore">use tauri::Manager;
use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu};

fn main() {
    let tray_menu = SystemTrayMenu::new(); // insert the menu items here
    tauri::Builder::default()
        .system_tray(SystemTray::new().with_menu(tray_menu))
        .on_system_tray_event(|app, event| match event {
            SystemTrayEvent::MenuItemClick { id, .. } =&gt; {
                // get a handle to the clicked menu item
                // note that `tray_handle` can be called anywhere,
                // just get a `AppHandle` instance
                // with `app.handle()` on the setup hook
                // and move it to another function or thread
                let item_handle = app.tray_handle().get_item(&amp;id);
                match id.as_str() {
                    &quot;hide&quot; =&gt; {
                        let window = app.get_window(&quot;main&quot;).unwrap();
                        window.hide().unwrap();
                        // you can also `set_selected`, `set_enabled`
                        // and `set_native_image` (macOS only).
                        item_handle.set_title(&quot;Show&quot;).unwrap();
                    }
                    _ =&gt; {}
                }
            }
            _ =&gt; {}
        })
        .run(tauri::generate_context!())
        .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h2 id="updating-the-tray-icon"><a class="header" href="#updating-the-tray-icon">Updating the Tray Icon</a></h2>
<p>Note that <code>tauri::Icon</code> must be a <code>Path</code> variant on Linux, and Raw
variant on Windows and macOS.</p>
<pre><code class="language-rust ignore">app.tray_handle()
        .set_icon(tauri::Icon::Raw(include_bytes!(&quot;../path/to/myicon.ico&quot;)))
        .unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sidecar-embedding-external-binaries"><a class="header" href="#sidecar-embedding-external-binaries">Sidecar (Embedding External Binaries)</a></h1>
<p>Tauri allows you to embed external binaries, to save your users from
installing additional dependencies (e.g., Node.js or Python).</p>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>To add a Sidecar binary to your Tauri app, add the executables'
absolute or relative path to the <a href="examples//docs/api/config#tauri.bundle"><code>tauri.bundle.externalBin</code></a> array.
The Tauri CLI will bundle all sidecars into the final package.</p>
<figure>
<pre><code class="language-diff">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;externalBin&quot;: [
+        &quot;/absolute/path/to/app&quot;,
+        &quot;relative/path/to/binary&quot;,
+        &quot;bin/python&quot;
      ]
    }
  }
}
</code></pre>
<figcaption>Listing 4-TODO: </figcaption>
</figure>
<p>When bundling the final application, the Tauri bundlers appends the
[target triple] to the specified path, so for example, with the
following configuration <code>&quot;externalBin&quot;: [&quot;bin/python&quot;]</code> Tauri will
attempt to bundle the following file
<code>src-tauri/bin/python-x86_64-unknown-linux-gnu</code> on x86 Linux and
<code>src-tauri/bin/python-aarch64-apple-darwin</code> on Apple silicon macOS.</p>
<p>To find your current platforms' target triple, open a terminal and
enter the following command:</p>
<pre><code class="language-console">rustc -Vv | grep host
</code></pre>
<p>Here's a Node.js script to append the target triple to a binary:</p>
<pre><code class="language-javascript">const execa = require(&quot;execa&quot;);
const fs = require(&quot;fs&quot;);

let extension = &quot;&quot;;
if (process.platform === &quot;win32&quot;) {
  extension = &quot;.exe&quot;;
}

async function main() {
  const rustInfo = (await execa(&quot;rustc&quot;, [&quot;-vV&quot;])).stdout;
  const targetTriple = /host: (\S+)/g.exec(rustInfo)[1];
  if (!targetTriple) {
    console.error(&quot;Failed to determine platform target triple&quot;);
  }
  fs.renameSync(
    `src-tauri/binaries/app${extension}`,
    `src-tauri/binaries/app-${targetTriple}${extension}`
  );
}

main().catch((e) =&gt; {
  throw e;
});
</code></pre>
<h2 id="running-the-sidecar-binary"><a class="header" href="#running-the-sidecar-binary">Running the Sidecar Binary</a></h2>
<p>Tauri takes care of bundling the Sidecar binary, but you are in charge
of actually running it. This means you are also in charge of killing
the child process when your app closes; otherwise, you pollute the
users' machine with orphan processes.</p>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<p>The <code>tauri::api::process::Command</code> struct provides a convenient
constructor for Sidecar binaries, <code>Command::new_sidecar</code>, that will
take care of appending the correct target triple to match the filename
you had to assign previously.</p>
<pre><code class="language-rust ignore">let (mut rx, mut child) = Command::new_sidecar(&quot;my-sidecar&quot;)
  .expect(&quot;failed to create `my-sidecar` binary command&quot;)
  .spawn()
  .expect(&quot;Failed to spawn sidecar&quot;);

tauri::async_runtime::spawn(async move {
  // read events such as stdout
  while let Some(event) = rx.recv().await {
    if let CommandEvent::Stdout(line) = event {
      window
        .emit(&quot;message&quot;, Some(format!(&quot;'{}'&quot;, line)))
        .expect(&quot;failed to emit event&quot;);
      // write to stdin
      child.write(&quot;message from Rust\n&quot;.as_bytes()).unwrap();
    }
  }
});
</code></pre>
<h3 id="javascript-2"><a class="header" href="#javascript-2">JavaScript</a></h3>
<p>In Frontend JavaScript code, you may use the <code>Command.sidecar</code> static
method that, in-turn takes care of appending the right target triple.</p>
<pre><code class="language-javascript">import { Command } from &quot;@tauri-apps/api/shell&quot;;
// alternatively, use `window.__TAURI__.shell.Command`
// `my-sidecar` is the value specified on `tauri.conf.json &gt; tauri &gt; bundle &gt; externalBin`
const command = Command.sidecar(&quot;my-sidecar&quot;);
const output = await command.execute();
</code></pre>
<h2 id="using-nodejs-as-a-sidecar"><a class="header" href="#using-nodejs-as-a-sidecar">Using Node.js as a Sidecar</a></h2>
<p>The sidecar feature can only bundle self-contained binaries, making
Node.js applications difficult to bundle. You can either include a
stock Node.js binary as a Sidecar and your JavaScript file as a
<a href="examples/../building/tauri-bundler.html#resources">Resource</a>, or compile the Node.js runtime and code into a standalone
binary using <a href="https://github.com/vercel/pkg">pkg</a>. The official Tauri <a href="https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar">sidecar example</a> demonstrates
the latter technique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="splashscreen"><a class="header" href="#splashscreen">Splashscreen</a></h1>
<p>In case your Frontend is rather heavy and takes some time to load, or
you need to perform some initialization procedures in Rust before
displaying your main window, a splash screen can improve the loading
experience for the user.</p>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<p>First, create a <code>splashscreen.html</code> in your <code>distDir</code> that contains
the HTML code for a splashscreen. Then, add the following to your
<code>tauri.conf.json</code>:</p>
<pre><code class="language-diff">&quot;windows&quot;: [
  {
    &quot;title&quot;: &quot;Tauri App&quot;,
    &quot;width&quot;: 800,
    &quot;height&quot;: 600,
    &quot;resizable&quot;: true,
    &quot;fullscreen&quot;: false,
+   &quot;visible&quot;: false // Hide the main window by default
  },
  // Add the splashscreen window
+ {
+   &quot;width&quot;: 400,
+   &quot;height&quot;: 200,
+   &quot;decorations&quot;: false,
+   &quot;url&quot;: &quot;splashscreen.html&quot;,
+   &quot;label&quot;: &quot;splashscreen&quot;
+ }
]
</code></pre>
<p>Your main window will be hidden, and the splashscreen window will show
when your app is launched. Next, you'll need a way to close the
splashscreen and show the main window when your app is ready. How you
do this depends on what you are waiting for before closing the
splashscreen.</p>
<h2 id="waiting-for-the-frontend"><a class="header" href="#waiting-for-the-frontend">Waiting for the Frontend</a></h2>
<p>If you are waiting for your web code, you'll want to create a
<code>close_splashscreen</code> <a href="examples/../development/inter-process-communication.html#commands">command</a>.</p>
<pre><code class="language-rust ignore">use tauri::Manager;
// Create the command:
// This command must be async so that it doesn't run on the main thread.
#[tauri::command]
async fn close_splashscreen(window: tauri::Window) {
  // Close splashscreen
  if let Some(splashscreen) = window.get_window(&quot;splashscreen&quot;) {
    splashscreen.close().unwrap();
  }
  // Show main window
  window.get_window(&quot;main&quot;).unwrap().show().unwrap();
}

// Register the command:
fn main() {
  tauri::Builder::default()
    // Add this line
    .invoke_handler(tauri::generate_handler![close_splashscreen])
    .run(tauri::generate_context!())
    .expect(&quot;failed to run app&quot;);
}
</code></pre>
<p>Then, you can call it from your Frontend:</p>
<pre><code class="language-javascript">// With the Tauri API npm package:
import { invoke } from &quot;@tauri-apps/api/tauri&quot;;
// With the Tauri global script:
const invoke = window.__TAURI__.invoke;

document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  // This will wait for the window to load, but you could
  // run this function on whatever trigger you want
  invoke(&quot;close_splashscreen&quot;);
});
</code></pre>
<h2 id="waiting-for-rust"><a class="header" href="#waiting-for-rust">Waiting for Rust</a></h2>
<p>If you are waiting for Rust code to run, put it in the <code>setup</code>
callback so you have access to the App instance:</p>
<pre><code class="language-rust ignore">use tauri::Manager;
fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let splashscreen_window = app.get_window(&quot;splashscreen&quot;).unwrap();
      let main_window = app.get_window(&quot;main&quot;).unwrap();
      // we perform the initialization code on a new task so the app doesn't freeze
      tauri::async_runtime::spawn(async move {
        // initialize your app here instead of sleeping :)
        println!(&quot;Initializing...&quot;);
        std::thread::sleep(std::time::Duration::from_secs(2));
        println!(&quot;Done initializing.&quot;);

        // After it's done, close the splashscreen and display the main window
        splashscreen_window.close().unwrap();
        main_window.show().unwrap();
      });
      Ok(())
    })
    .run(tauri::generate_context!())
    .expect(&quot;failed to run app&quot;);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="icons"><a class="header" href="#icons">Icons</a></h1>
<p>Tauri ships with a default iconset based on its logo. This is probably
NOT what you want when you ship your application. To help with this
common situation, Tauri provides the <a href="https://github.com/tauri-apps/tauricon"><code>tauricon</code></a> command that will
take an input file (<code>&quot;./app-icon.png&quot;</code> by default) and create all the
icons needed for the various platforms:</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>You can install the <a href="https://github.com/tauri-apps/tauricon"><code>tauricon</code></a> package either locally as a dev
dependency:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install -D github:tauri-apps/tauricon
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -D github:tauri-apps/tauricon
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -D github:tauri-apps/tauricon
</code></pre>
<p>or globally:</p>
<p><strong>npm</strong></p>
<pre><code class="language-console">npm install -g github:tauri-apps/tauricon
</code></pre>
<p><strong>yarn</strong></p>
<pre><code class="language-console">yarn add -g github:tauri-apps/tauricon
</code></pre>
<p><strong>pnpm</strong></p>
<pre><code class="language-console">pnpm add -g github:tauri-apps/tauricon
</code></pre>
<p>If you decide to use <code>tauricon</code> as a local package with npm (not
yarn), you need to add a custom script to your package.json:
package.json</p>
<pre><code class="language-diff">{
  &quot;scripts&quot;: {
+    &quot;tauricon&quot;: &quot;tauricon&quot;
  }
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-text">npm tauricon --help

Description
  Create all the icons you need for your Tauri app.
  The icon path is the source icon (png, 1240x1240 with transparency), it defaults
  to './app-icon.png'.

Usage
  tauricon [ICON-PATH]

Options
  --help, -h          Displays this message
  --log, l            Logging [boolean]
  --target, t         Target folder (default: 'src-tauri/icons')
  --compression, c    Compression type [optipng|zopfli]
  --ci                Runs the script in CI mode
</code></pre>
<p>Created icons will be placed in your <code>src-tauri/icons</code> folder, where
they will automatically be included in your built app.</p>
<p>If you need to source your icons from some other location, you can
edit this part of the <code>src-tauri/tauri.conf.json</code> file:</p>
<pre><code class="language-diff">{
  &quot;tauri&quot;: {
    &quot;bundle&quot;: {
      &quot;icon&quot;: [
-        &quot;icons/32x32.png&quot;,
-        &quot;icons/128x128.png&quot;,
-        &quot;icons/128x128@2x.png&quot;,
-        &quot;icons/icon.icns&quot;,
-        &quot;icons/icon.ico&quot;
+        &quot;otherpath/icons/32x32.png&quot;,
+        &quot;otherpath/icons/128x128.png&quot;,
+        &quot;otherpath/icons/128x128@2x.png&quot;,
+        &quot;otherpath/icons/icon.icns&quot;,
+        &quot;otherpath/icons/icon.ico&quot;
      ]
    }
  }
}
</code></pre>
<blockquote>
<p>Note on filetypes:</p>
<ul>
<li><code>.icns</code> is used for macOS builds</li>
<li><code>.ico</code> is used for Windows builds</li>
<li><code>.png</code> is used for Linux builds</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>With Tauri you can give your app a Command Line Interface (CLI)
through <a href="https://github.com/clap-rs/clap">clap</a>, a robust command-line argument parser written in Rust.
With a simple CLI configuration in your <code>tauri.conf.json</code> file, you
can define your interface and read its argument matches map on
JavaScript and/or Rust.</p>
<h2 id="base-configuration"><a class="header" href="#base-configuration">Base Configuration</a></h2>
<p>Under <code>tauri.conf.json</code>, you have the following structure to configure
the interface:</p>
<p>Filename: src-tauri/tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;tauri&quot;: {
    &quot;cli&quot;: {
      // command description that's shown on help
      &quot;description&quot;: &quot;&quot;,
      // command long description that's shown on help
      &quot;longDescription&quot;: &quot;&quot;,
      // content to show before the help text
      &quot;beforeHelp&quot;: &quot;&quot;,
      // content to show after the help text
      &quot;afterHelp&quot;: &quot;&quot;,
      // list of arguments of the command, we'll explain it later
      &quot;args&quot;: [],
      &quot;subcommands&quot;: {
        &quot;subcommand-name&quot;: {
          // configures a subcommand that is accessible
          // with `./app subcommand-name --arg1 --arg2 --etc`
          // configuration as above, with &quot;description&quot;, &quot;args&quot;, etc.
        }
      }
    }
  }
}
</code></pre>
<blockquote>
<p>Note: All JSON configurations here are just samples, many other
fields have been omitted for the sake of clarity.</p>
</blockquote>
<h2 id="adding-arguments"><a class="header" href="#adding-arguments">Adding Arguments</a></h2>
<p>The <code>args</code> array represents the list of arguments accepted by its
command or subcommand. You can find more details about the way to
configure them <a href="examples//docs/api/config#tauri">here</a>.</p>
<h3 id="positional-arguments"><a class="header" href="#positional-arguments">Positional Arguments</a></h3>
<p>A positional argument is identified by its position in the list of
arguments. With the following configuration:</p>
<p>Filename: src-tauri/tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;args&quot;: [
    {
      &quot;name&quot;: &quot;source&quot;,
      &quot;index&quot;: 1,
      &quot;takesValue&quot;: true
    },
    {
      &quot;name&quot;: &quot;destination&quot;,
      &quot;index&quot;: 2,
      &quot;takesValue&quot;: true
    }
  ]
}
</code></pre>
<p>Users can run your app as <code>./app tauri.txt dest.txt</code> and the arg
matches map will define <code>source</code> as <code>&quot;tauri.txt&quot;</code> and <code>destination</code> as
<code>&quot;dest.txt&quot;</code>.</p>
<h3 id="named-arguments"><a class="header" href="#named-arguments">Named Arguments</a></h3>
<p>A named argument is a (key, value) pair where the key identifies the
value. With the following configuration:</p>
<p>Filename: src-tauri/tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;args&quot;: [
    {
      &quot;name&quot;: &quot;type&quot;,
      &quot;short&quot;: &quot;t&quot;,
      &quot;takesValue&quot;: true,
      &quot;multiple&quot;: true,
      &quot;possibleValues&quot;: [&quot;foo&quot;, &quot;bar&quot;]
    }
  ]
}
</code></pre>
<p>Users can run your app as <code>./app --type foo bar</code>,
<code>./app -t foo -t bar</code> or <code>./app --type=foo,bar</code> and the arg matches
map will define <code>type</code> as <code>[&quot;foo&quot;, &quot;bar&quot;]</code>.</p>
<h3 id="flag-arguments"><a class="header" href="#flag-arguments">Flag Arguments</a></h3>
<p>A flag argument is a standalone key whose presence or absence provides
information to your application. With the following configuration:</p>
<p>Filename: src-tauri/tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;args&quot;: [
    &quot;name&quot;: &quot;verbose&quot;,
    &quot;short&quot;: &quot;v&quot;,
    &quot;multipleOccurrences&quot;: true
  ]
}
</code></pre>
<p>Users can run your app as <code>./app -v -v -v</code>,
<code>./app --verbose --verbose --verbose</code> or <code>./app -vvv</code> and the arg
matches map will define <code>verbose</code> as <code>true</code>, with <code>occurrences = 3</code>.</p>
<h2 id="subcommands"><a class="header" href="#subcommands">Subcommands</a></h2>
<p>Some CLI applications has additional interfaces as subcommands. For
instance, the <code>git</code> CLI has <code>git branch</code>, <code>git commit</code> and <code>git push</code>.
You can define additional nested interfaces with the <code>subcommands</code>
array:</p>
<p>Filename: src-tauri/tauri.conf.json</p>
<pre><code class="language-json">{
  &quot;cli&quot;: {
    ...
    &quot;subcommands&quot;: {
      &quot;branch&quot;: {
        &quot;args&quot;: []
      },
      &quot;push&quot;: {
        &quot;args&quot;: []
      }
    }
  }
}
</code></pre>
<p>Its configuration is the same as the root application configuration,
with the <code>description</code>, <code>longDescription</code>, <code>args</code>, etc.</p>
<h2 id="reading-the-matches"><a class="header" href="#reading-the-matches">Reading the matches</a></h2>
<h3 id="rust-3"><a class="header" href="#rust-3">Rust</a></h3>
<pre><code class="language-rust ignore">use tauri::api::cli::get_matches;

fn main() {
    let context = tauri::generate_context!();
    let cli_config = context.config().tauri.cli.clone().unwrap();

    match get_matches(&amp;cli_config) {
        // `matches` here is a Struct with { args, subcommand }.
        // `args` is `HashMap&lt;String, ArgData&gt;`
        // where `ArgData` is a struct with { value, occurances }.
        // `subcommand` is `Option&lt;Box&lt;SubcommandMatches&gt;&gt;`
        // where `SubcommandMatches` is a struct with { name, matches }.
        Ok(matches) =&gt; {
            println!(&quot;{:?}&quot;, matches)
        }
        Err(_) =&gt; {}
    };

    tauri::Builder::default()
        .run(context)
        .expect(&quot;error while running tauri application&quot;);
}
</code></pre>
<h3 id="javascript-3"><a class="header" href="#javascript-3">JavaScript</a></h3>
<pre><code class="language-javascript">import { getMatches } from &quot;@tauri-apps/api/cli&quot;;

getMatches().then((matches) =&gt; {
  // do something with the { args, subcommand } matches
});
</code></pre>
<h2 id="complete-documentation"><a class="header" href="#complete-documentation">Complete documentation</a></h2>
<p>You can find more about the CLI configuration <a href="examples//docs/api/config#tauri">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-version-tables"><a class="header" href="#appendix-c-version-tables">Appendix C: Version Tables</a></h1>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<table><thead><tr><th>macOS</th><th>safari</th><th>webkit</th><th>note</th></tr></thead><tbody>
<tr><td>12.3</td><td>15.4</td><td>17613</td><td></td></tr>
<tr><td>12.2</td><td>15.3</td><td>17612</td><td></td></tr>
<tr><td>12.1</td><td>15.2</td><td></td><td></td></tr>
<tr><td>12.0</td><td>15.0</td><td></td><td></td></tr>
<tr><td>11.3</td><td>14.1</td><td>611</td><td>This one is a guess because of the same release date</td></tr>
<tr><td>11.0</td><td>14.0</td><td>610</td><td></td></tr>
<tr><td>10.15</td><td>13.x</td><td>608</td><td></td></tr>
<tr><td>10.14</td><td>12.x</td><td>606/607</td><td>10.14.4 upgraded safari to 12.1 - No idea if that's true for the system webview too</td></tr>
<tr><td>10.13</td><td>11.x</td><td>604/605</td><td>10.13.5 upgraded safari to 11.1 - No idea if that's true for the system webview too</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="d---json-schemas"><a class="header" href="#d---json-schemas">D - JSON Schemas</a></h1>
<h2 id="dynamic-json-format-1"><a class="header" href="#dynamic-json-format-1">Dynamic JSON Format</a></h2>
<figure>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;additionalProperties&quot;: false,
  &quot;required&quot;: [&quot;url&quot;, &quot;version&quot;],
  &quot;properties&quot;: {
    &quot;url&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;version&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;pub_date&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;notes&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;signature&quot;: { &quot;type&quot;: &quot;string&quot; }
  }
}
</code></pre>
<figcaption>Listing D-1: Formal schema for the updater's dynamic JSON format.</figcaption>
</figure>
<h2 id="static-json-format-1"><a class="header" href="#static-json-format-1">Static JSON Format</a></h2>
<figure>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;additionalProperties&quot;: false,
  &quot;required&quot;: [&quot;version&quot;],
  &quot;properties&quot;: {
    &quot;version&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;pub_date&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;notes&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;platforms&quot;: {
      &quot;type&quot;: &quot;object&quot;,
      &quot;additionalProperties&quot;: false,
      &quot;patternProperties&quot;: {
        &quot;^(linux|windows|darwin)-(x86_64|i686|aarch64|armv7)$&quot;: {
          &quot;type&quot;: &quot;object&quot;,
          &quot;required&quot;: [&quot;url&quot;],
          &quot;properties&quot;: {
            &quot;url&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;signature&quot;: { &quot;type&quot;: &quot;string&quot; },
            &quot;with_elevated_task&quot;: { &quot;type&quot;: &quot;boolean&quot; }
          }
        }
      }
    }
  }
}
</code></pre>
<figcaption>Listing D-2: Formal schema for the updater's static JSON format.</figcaption>
</figure>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/mermaid.min.js"></script>
        <script type="text/javascript" src="theme/mermaid-init.js"></script>
        <script type="text/javascript" src="theme/ferris.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
